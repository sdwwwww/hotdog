CRLF_SJIS

    mennuu
        -label "Object / Component" 
        -divider 0
        -subMenu 0
        -tearOff 0
        -command "global proc CurveOperation(string $cmd){\nif(size(`ls-sl`)!=0){\nglobal string $graphobj0[];\nglobal int $keyjige0;\nglobal int $sttime0;\nglobal int $edtime0;\nglobal float $selkeyall0[];\nglobal int $notime0;\nglobal string $selcurves0[];\nglobal string $selcurvesb0[];\nglobal int $channelshu0;\nglobal float $FrameA0;\nglobal float $FrameB0;\nglobal string $mmkey0;\nglobal float $prekey0;\nglobal float $nexkey0;\nglobal string $selchan0[];son0;\n\tif ($cmd == \"threekeyadd\" || $cmd == \"LRkeycut\" || $cmd == \"allzero\" || $cmd == \"Tzero\" || $cmd == \"Rzero\"  \n\t|| $cmd == \"Szero\" || $cmd == \"delekey\" || $cmd == \"setkeya_b\" || $cmd == \"setkeyc_d\" || $cmd == \"selkeya_b\" || $cmd == \"selkeyc_d\"){//{1\n\t\tswitch ($cmd) {\n\t\t\tcase \"threekeyadd\":\n\t\t\t\t//if(size($selchan0)!=0){\n\t\t\t\t//\tchannelBoxCommand -key;\n\t\t\t\t//\tsetKeyframe -animated 1 -t $sttime0 -t $edtime0;\n\t\t\t\t//}else{\n\t\t\t\t\tif($channelshu0==0){\n\t\t\t\t\t\tSetKeyTranslate;SetKeyRotate;\n\t\t\t\t\t\tsetKeyframe -animated 1 -t $sttime0 -t $edtime0;//lei si chuan ran\n\t\t\t\t\t}else{\n\t\t\t\t    if($keyjige0!=0){\n\t\t\t\t\t\tfor ($x=$FrameA0;$x<$FrameB0;$x++){\n\t\t\t\t\t\t\tsetKeyframe -insert -t $x $selcurves0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tsetKeyframe -insert -t $notime0 $graphobj0;\n\t\t\t\t\t\tsetKeyframe -insert -t ($notime0+1) $graphobj0;\n\t\t\t\t\t\tsetKeyframe -insert -t ($notime0-1) $graphobj0;\n\t\t\t\t\t}\n\t\t\t\t//}\n\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"LRkeycut\":\n\t\t\t\tSetKeyAnimated;\n\t\t\t\tselectKey -k -t $prekey0 -t $nexkey0;cutKey -clear;\n\t\t\tbreak;\n\t\t\tcase \"allzero\":\n\t\t\t\tif ($keyjige0 == 0) {\n\t\t\t\t\tsetKeyframe -insert -t -500;\n\t\t\t\t\tselectKey -k -t -500;\n\t\t\t\t\tkeyframe -valueChange 0;\n\t\t\t\t\tfilterCurve;\n\t\t\t\t\tcutKey -clear;\n\t\t\t\t}else{\n\t\t\t\t\tkeyframe -animation keys -absolute -valueChange 0 ;\n\t\t\t\t\t//TangentsAuto;\n\t\t\t\t\tgeDoKeyTangent \"-e -itt auto -ott auto\";\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"Tzero\":\n\t\t\t\tfor($a in `ls-sl`){\n\t\t\t\t\tsetAttr ($a + \".tx\")  0;\n\t\t\t\t\tsetAttr ($a + \".ty\")  0;\n\t\t\t\t\tsetAttr ($a + \".tz\")  0;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"Rzero\":\n\t\t\t\tfor($a in `ls-sl`){\n\t\t\t\t\tsetAttr ($a + \".rx\")  0;\n\t\t\t\t\tsetAttr ($a + \".ry\")  0;\n\t\t\t\t\tsetAttr ($a + \".rz\")  0;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"Szero\":\n\t\t\t\tfor($a in `ls-sl`){\n\t\t\t\t\tsetAttr ($a + \".sx\") 1;\n\t\t\t\t\tsetAttr ($a + \".sy\") 1;\n\t\t\t\t\tsetAttr ($a + \".sz\") 1;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"delekey\":\n\t\t\t\tif($keyjige0==0) {\n\t\t\t\t\tCurveOperation onekeyselect;\n\t\t\t\t\tif(`keyframe -an keys -q -kc`!=0){cutKey -clear;}\n\t\t\t\t}else if($keyjige0!=0){\n\t\t\t\t\tcutKey -clear;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"setkeya_b\":\n\t\t\t\tglobal float $Fra_a;\n\t\t\t\tglobal float $Fra_b;\n\t\t\t\tfloat $allKeys[] = sort(`keyframe -q -sl`);\n\t\t\t\t$Fra_a = $allKeys[0];\n\t\t\t\t$Fra_b = $allKeys[(size($allKeys) -1)];\n\t\t\tbreak;\n\t\t\tcase \"setkeyc_d\":\n\t\t\t\tglobal float $Fra_c;\n\t\t\t\tglobal float $Fra_d;\n\t\t\t\tfloat $allKeys2[] = sort(`keyframe -q -sl`);\n\t\t\t\t$Fra_c = $allKeys2[0];\n\t\t\t\t$Fra_d = $allKeys2[(size($allKeys2) -1)];\n\t\t\tbreak;\n\t\t\tcase \"selkeya_b\":\n\t\t\t\tif ($keyjige0 == 0) {\n\t\t\t\t\tglobal float $Fra_a;\n\t\t\t\t\tglobal float $Fra_b;\n\t\t\t\t\tselectKey -k -t ( $Fra_a + \":\" +  $Fra_b ) $selcurves0;\n\t\t\t\t}else{\n\t\t\t\t\tselectKey -k -t ( $Fra_a + \":\" +  $Fra_b ) $selcurves0;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"selkeyc_d\":\n\t\t\t\tif ($keyjige0 == 0) {\n\t\t\t\t\tglobal float $Fra_c;\n\t\t\t\t\tglobal float $Fra_d;\n\t\t\t\t\tselectKey -k -t ( $Fra_c + \":\" +  $Fra_d ) $selcurves0;\n\t\t\t\t}else{\n\t\t\t\t\tselectKey -k -t ( $Fra_c + \":\" +  $Fra_d ) $selcurves0;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}else if ($cmd == \"onekeyadd\" || $cmd == \"onekeyselect\" || $cmd == \"guodukeyA\" || $cmd == \"guodukeyB\"){//=HoldCurrentKeys\n\t\tswitch ($cmd) {\n\t\t\tcase \"onekeyadd\":\n\t\t\t\tif ($keyjige0 == 0) {\n\t\t\t\t    setKeyframe -insert -t $notime0 $graphobj0;\n\t\t\t\t}else{\n\t\t\t    \tsetKeyframe -insert -t $notime0 $selcurves0;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"onekeyselect\":\n\t\t\t\tif ($keyjige0 == 0) {\n\t\t\t\t    selectKey -k -t $notime0;\n\t\t\t\t}else{\n\t\t\t    \tselectKey -k -t $notime0 $selcurves0;\n\t\t\t\t}print (\">>> \"+size(sort(`keyframe -q -sl`))+\" <<<\");\n\t\t\tbreak;\n\t\t\tcase \"guodukeyA\":\n\t\t\t\tif ($keyjige0 == 0) {\n\t\t\t\t\tCurveOperation threekeyadd;\n\t\t\t\t\tCurveOperation delekey;\n\t\t\t\t\tSetKeyAnimated;\n\t\t\t\t}else{\n\t\t\t\t\tsetKeyframe -insert -t ($FrameA0-1) $selcurves0;\n\t\t\t\t\tsetKeyframe -insert -t ($FrameA0+1) $selcurves0;\n\t\t\t\t\tselectKey -k -t ($FrameA0-1) -t ($FrameA0+1) $selcurves0;\n\t\t\t\t\tkeyTangent -e -itt auto -ott auto;\n\t\t\t\t\tselectKey -k -t $FrameA0 $selcurves0;\n\t\t\t\t\tCurveOperation delekey;\n\t\t\t\t\tsetKeyframe -insert -t $FrameA0 $selcurves0;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"guodukeyB\":\n\t\t\t\tif ($keyjige0 == 0) {\n\t\t\t\t\tCurveOperation delekey;\n\t\t\t\t\tSetKeyAnimated;\n\t\t\t\t}else{\n\t\t\t\t\tCurveOperation delekey;\n\t\t\t\t\tsetKeyframe -insert -t $FrameA0 $selcurves0;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n/*-\t}else if ($cmd == \"scalekey10\" || $cmd == \"scalekey50\" || $cmd == \"scalekey100\" || $cmd == \"scalekeyP10\" || $cmd == \"scalekeyP50\"){\n\t\tif ($keyjige0 != 0) {\n\t\t\tfor ($c = 0; $c<$channelshu0; $c++){\n\t\t\tselectKey -k -t $mmkey0 $selcurves0[$c];\n\t\t\t\tswitch ($cmd) {\n\t\t\t\t\tcase \"scalekey10\":\n\t\t\t\t\t\tpython \"import sonCurvee;reload(sonCurvee); sonCurvee.Updatego10();\";\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"scalekey50\":\n\t\t\t\t\t\tpython \"import sonCurvee;reload(sonCurvee); sonCurvee.Updatego50();\";\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"scalekey100\":\n\t\t\t\t\t\tpython \"import sonCurvee;reload(sonCurvee); sonCurvee.Updatego();\";\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"scalekeyP10\":\n\t\t\t\t\t\tpython \"import sonCurvee;reload(sonCurvee); sonCurvee.UpdategoP10();\";\n\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"scalekeyP50\":\n\t\t\t\t\t\tpython \"import sonCurvee;reload(sonCurvee); sonCurvee.UpdategoP50();\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}selectKey -k -t $mmkey0 $selcurves0;\n\t\t}-*/\n\t}else if ($cmd == \"selectkeyA_B\" || $cmd == \"selectKeyWminus\" || $cmd == \"selectKeyWplus\" || $cmd == \"selectKeyLminus\" || \n\t$cmd == \"selectKeyRminus\" || $cmd == \"foundpreviouskey\" || $cmd == \"foundnextkey\"){\n\t\tif ($keyjige0 != 0) {\n\t\t\tswitch ($cmd) {\n\t\t\t\tcase \"selectkeyA_B\":\n\t\t\t\t    if($FrameA0!=$FrameB0){\n\t\t\t\t\t    selectKey -k -t $mmkey0 $selcurves0;\n\t\t\t\t\t}else if($FrameA0==$FrameB0){\n\t\t\t\t\t    selectKey -k -t ($FrameA0+\":\"+$notime0) $selcurves0;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t\tcase \"selectKeyWminus\":\n\t\t\t\t\tint $wma = $FrameA0+1;int $wmb = $FrameB0-1;\n\t\t\t\t\tselectKey -k -t ($wma+\":\"+$wmb) $selcurves0;\n\t\t\t\tbreak;\n\t\t\t\tcase \"selectKeyWplus\":\n\t\t\t\t\tCurveOperation\"foundpreviouskey\";\n\t\t\t\t\tCurveOperation\"foundnextkey\";\n\t\t\t\tbreak;\n\t\t\t\tcase \"selectKeyLminus\":\n\t\t\t\t\tint $wmaa = $FrameA0+1;\n\t\t\t\t\tselectKey -k -t ($wmaa+\":\"+$FrameB0) $selcurves0;\n\t\t\t\tbreak;\n\t\t\t\tcase \"selectKeyRminus\":\n\t\t\t\t\tint $wmbb = $FrameB0-1;\n\t\t\t\t\tselectKey -k -t ($FrameA0+\":\"+$wmbb) $selcurves0;\n\t\t\t\tbreak;\n\t\t\t\tcase \"foundpreviouskey\"://L+\n    \t\t\t\tselectKey -add -k -t (`findKeyframe -t $FrameA0 -which previous`) $selcurves0;\n\t\t\t\tbreak;\n\t\t\t\tcase \"foundnextkey\"://R+\n\t\t\t\t\tselectKey -add -k -t (`findKeyframe -t $FrameB0 -which next`) $selcurves0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}else if ($cmd == \"Key_selobj\" || $cmd == \"guolvtime\"){\n\t\tswitch ($cmd) {\n\t\t\tcase \"Key_selobj\":\n\t\t\t\tif($keyjige0 != 0){\n\t\t\t\t\tint $ChannelCount=size($selcurvesb0);\n\t\t\t\t\tstring $CurveNames[];\n\t\t\t\t\tstring $ObjectNames[];\n\t\t\t\t\tfor ($e=0; $e<$ChannelCount; ++$e){\n\t\t\t\t\t\t$CurveNames[$e] = `match \"[^/\\\\.]*$\" $selcurvesb0[$e]`; \n\t\t\t\t\t\t$ObjectNames[$e] = `match \"^[^\\.]*\" $selcurvesb0[$e]`;\n\t\t\t\t\t}\n\t\t\t\t\tstring $Objects[] = stringArrayRemoveDuplicates($ObjectNames);\n\t\t\t\t\tprint \"\";// Avoids MEL message \n\t\t\t\t\tselect -cl ;\n\t\t\t\t\tselect $Objects;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"guolvtime\":\n\t\t\t\tglobal float $guolvhou[];\n\t\t\t\tint $p=-1;\n\t\t\t\tfloat $newaa[];\n\t\t\t\tfor($i=0;$i<`size($selkeyall0)`;$i++){\n\t\t\t\t\tint $t=$i+1;\n\t\t\t\t\tif($selkeyall0[$i]!= $selkeyall0[$t]){\n\t\t\t\t\t\t$newaa[0]=$selkeyall0[$i];\n\t\t\t\t\t\t$p++;\n\t\t\t\t\t\t$guolvhou[$p]=$newaa[0];\n\t\t\t\t\t}\n\t\t\t\t}print (`size($selkeyall0)`+\">\"+`size($guolvhou)`+\"--------\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n}//CurveOperation;\n////////\n////////\n////////\nglobal proc showchwork(int $type){//0all 1T 2R 3S 4TR 9onebyone 10channel>show\n//21-22-23>Txyz 31-32-33>Rxyz\nglobal int $jilu;\nif(size(`ls-sl`)==0){\n$jilu=0;\nprint \"no no no\";\n}else{\nglobal string $selobj0[];\nglobal string $lianjie0;\nglobal string $selcurves0[];\nglobal string $selchan0[];\nglobal int $notime0;son0;\n\nselectionConnection -e -clear $lianjie0;\nif($type==0){\nfor($obj in $selobj0){\nselectionConnection -e -select $obj $lianjie0;\n}}else if($type==1){\nfor($obj in $selobj0){\nselectionConnection -e -select ($obj + \".\" + \"tx\") $lianjie0;\nselectionConnection -e -select ($obj + \".\" + \"tz\") $lianjie0;\nselectionConnection -e -select ($obj + \".\" + \"ty\") $lianjie0;\n}}else if($type==2){\nfor($obj in $selobj0){\nselectionConnection -e -select ($obj + \".\" + \"rx\") $lianjie0;\nselectionConnection -e -select ($obj + \".\" + \"rz\") $lianjie0;\nselectionConnection -e -select ($obj + \".\" + \"ry\") $lianjie0;\n}}else if($type==3){\nfor($obj in $selobj0){\nselectionConnection -e -select ($obj + \".\" + \"sx\") $lianjie0;\nselectionConnection -e -select ($obj + \".\" + \"sz\") $lianjie0;\nselectionConnection -e -select ($obj + \".\" + \"sy\") $lianjie0;\n}}else if($type==4){\nfor($obj in $selobj0){\nselectionConnection -e -select ($obj + \".\" + \"tx\") $lianjie0;\nselectionConnection -e -select ($obj + \".\" + \"tz\") $lianjie0;\nselectionConnection -e -select ($obj + \".\" + \"ty\") $lianjie0;\nselectionConnection -e -select ($obj + \".\" + \"rx\") $lianjie0;\nselectionConnection -e -select ($obj + \".\" + \"rz\") $lianjie0;\nselectionConnection -e -select ($obj + \".\" + \"ry\") $lianjie0;\n}}\n\nelse if($type==21){\nfor($obj in $selobj0){\nselectionConnection -e -select ($obj + \".\" + \"tx\") $lianjie0;\n}}\nelse if($type==22){\nfor($obj in $selobj0){\nselectionConnection -e -select ($obj + \".\" + \"ty\") $lianjie0;\n}}\nelse if($type==23){\nfor($obj in $selobj0){\nselectionConnection -e -select ($obj + \".\" + \"tz\") $lianjie0;\n}}\n\nelse if($type==31){\nfor($obj in $selobj0){\nselectionConnection -e -select ($obj + \".\" + \"rx\") $lianjie0;\n}}\nelse if($type==32){\nfor($obj in $selobj0){\nselectionConnection -e -select ($obj + \".\" + \"ry\") $lianjie0;\n}}\nelse if($type==33){\nfor($obj in $selobj0){\nselectionConnection -e -select ($obj + \".\" + \"rz\") $lianjie0;\n}}\n\n///\nelse if($type==9){\n$channelB=`listConnections -plugs true $selcurves0`;\nif($jilu<`size($channelB)`){\n$jilu=$jilu+1;\nprint $jilu;\nint $aa=$jilu-1;\nselectionConnection -e -clear $lianjie0;\nselectionConnection -e -select $channelB[$aa] $lianjie0;\n}else{\nshowchwork(0);\n$jilu=0;\n}}\n///\nelse if($type==10){\nif(size($selchan0)>0){\nselectionConnection -e -clear $lianjie0;\nfor( $obj in $selobj0 ){\nfor($a in $selchan0){\nselectionConnection -e -select ($obj + \".\" + $a) $lianjie0;\n//selectKey -k -t $notime0 ($obj + \".\" + $a);\n}}\n///\n}\n//\n}\n}\n}\n////////\n////////\n////////\nglobal proc CurveOperation2(string $cmd){\nglobal int $selshu0;\nglobal int $sttime0;\nglobal int $edtime0;\nglobal string $mmtime0;\nglobal int $notime0;\nglobal float $Pls0;\nglobal float $Ple0;\nglobal string $selcurves0[];\nglobal int $keyjige0;\nglobal float $FrameA0;\nglobal float $FrameB0;son0;\n\tif ($cmd == \"seleminmax\" || $cmd == \"showminmax\" || $cmd == \"gostartend\"){\n\t\tswitch ($cmd) {\n\t\t\tcase \"seleminmax\":\n\t\t\t\tif($selshu0!=0){\n\t\t\t\t\tif($keyjige0==0){\n\t\t\t\t\t\tselectKey -t $mmtime0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tselectKey -t $mmtime0 $selcurves0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"showminmax\":\n\t\t\t\tif($keyjige0!=0){\n\t\t\t\t\tif ($notime0==$FrameA0){\n\t\t\t\t\t\tcurrentTime $FrameB0;\n\t\t\t\t\t}else if($notime0==$FrameB0){\n\t\t\t\t\t\tcurrentTime $FrameA0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcurrentTime $FrameA0;\n\t\t\t\t\t} \n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"gostartend\":\n\t\t\t\tif ($notime0==$sttime0){\n\t\t\t\t\tcurrentTime $edtime0;\n\t\t\t\t}else{\n\t\t\t\t\tcurrentTime $sttime0; \n\t\t\t\t}  \n\t\t\tbreak;\n\t\t}\n\t}else if($cmd == \"tquickPB1\" ||$cmd == \"tquickPB2\" ||$cmd == \"tquickPB3\" ||$cmd == \"tquickPB4\"){\n\t\tswitch ($cmd) {\n\t\t\tcase \"tquickPB1\":\n\t\t\t\tif($Ple0-1!=$Pls0){\n\t\t\t\t\tplaybackOptions -min $Pls0 -max $Ple0;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"tquickPB2\":\n\t\t\t\tif($keyjige0!=0){\n\t\t\t\t\tplaybackOptions -min $FrameA0 -max $FrameB0;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"tquickPB3\":\n\t\t\t\tplaybackOptions -min $notime0;\n\t\t\tbreak;\n\t\t\tcase \"tquickPB4\":\n\t\t\t\tplaybackOptions -max $notime0;\n\t\t\tbreak;\n\t\t}\n\t}\n}//CurveOperation2;" 
        -optionBox 0
        -enable 1
        -visible 1
        -data 0
        -radialPosition "NW" 
        -allowOptionBoxes 1
        -postMenuCommandOnce 0
        -enableCommandRepeat 1
        -echoCommand 0
        -italicized 0
        -boldFont 1
        -sourceType "mel" 
        -longDivider 1
        menuEditorMenuItem1;

    mennuu
        -label "Animation mask" 
        -divider 0
        -subMenu 0
        -tearOff 0
        -command "//$ackSetup_pivot = \"left\";\n//$ackSetup_affect = \"individual\";\n//$ackSetup_scaleFactor = .9;\nglobal proc ackPushPull(string $cmd){\n\t//only run if at least one key is selected\n\t$keyCount = `keyframe -an keys -q -keyframeCount`;\n\tif ($keyCount != 0) {\n\t\t//ackSetup Globals\n\t\tglobal string $ackSetup_pivot;\n\t\tglobal string $ackSetup_affect;\n\t\tglobal float $ackSetup_scaleFactor;\n\n\t\t//set default value if doesn't exist\n\t\tif ($ackSetup_pivot == \"\"){\n\t\t\t$ackSetup_pivot = \"left\";\n\t\t}\n\t\tif ($ackSetup_affect == \"\"){\n\t\t\t$ackSetup_affect = \"individual\";\n\t\t}\n\t\tif ($ackSetup_scaleFactor <= .0001){\n\t\t\t$ackSetup_scaleFactor = .9;\n\t\t}\n\n\t\tfloat $pivotTime;\n\t\tfloat $pivotValue[];\n\n\t\tif ($ackSetup_pivot == \"last\"){\n\t\t\t$pivotValue = `keyframe -lastSelected -q -valueChange`;\t\n\t\t}\t\t\t\n\n\t\t//loop over selected curves and process independently\n\t\tstring $selectedCurves[] = `keyframe -selected -q -name`;\n\t\tfor ($c = 0; $c < size($selectedCurves); $c++){\n\t\t\t//channel to use for this pass\n\t\t\t$channel = $selectedCurves[$c];\n\n\t\t\t//get array of key times in selection (to find closest match key)\n\t\t\t$timeArray = `keyframe -selected -q -timeChange $channel`;\n\n\t\t\t//get pivot point\n\n\t\t\tswitch ($ackSetup_pivot){\n\t\t\t\tcase \"left\":\n\t\t\t\t\t$pivotTime = `findKeyframe -which \"previous\" -time $timeArray[0] $channel`;\n\t\t\t\t\t$pivotValue = `keyframe -time $pivotTime -q -valueChange $channel`;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"right\":\n\t\t\t\t\tint $lastKey = size($timeArray) - 1;\n\t\t\t\t\t$pivotTime = `findKeyframe -which \"next\" -time $timeArray[$lastKey] $channel`;\n\t\t\t\t\t$pivotValue = `keyframe -time $pivotTime -q -valueChange $channel`;\n\t\t\t\t\tbreak;\n\t\t\t}\n///////////////////////////////////////////////////////\n///////////////////////////////////////////////////////Snap\n\t\t\t//$timeArray = `keyframe -selected -q -timeChange $channel`;\n\t\t\t//find first frame time\n\t\t\t$lastkeySnap = `keyframe -q -lastSelected $channel`;\n\t\t\t$firstKey = $lastkeySnap[0];\n\t\t\t$firstKey2 = $lastkeySnap[0];\n\t\t\tfor ($j = 0; $j < size($timeArray); $j++){\n\t\t\t\tif ($timeArray[$j] < $firstKey){\n\t\t\t\t\t$firstKey = $timeArray[$j];\n\t\t\t\t}\n\t\t\t\t$firstKey2 = $timeArray[$j];\n\t\t\t}\n\t\t\n\t\t\t//get array of key values in selection\n\t\t\t$timeArraySnap = `keyframe -selected -q -valueChange $channel`;\n\t\t\t\n\t\t\t//find closest key to the left\n\t\t\t$matchKey = `findKeyframe -time $firstKey -which previous $channel`;\n\t\t\t$matchKey2 = `findKeyframe -time $firstKey2 -which next $channel`;\n\t\t\t\n\t\t\t//get difference in values between firstKey and matchKey\n\t\t\t$matchKey_val = `keyframe -time $matchKey -q -valueChange $channel`;\n\t\t\t$firstKey_val = `keyframe -time $firstKey -q -valueChange $channel`;\n\t\t\t$delta = $matchKey_val[0] - $firstKey_val[0];\n\t\t\t//////////////////////////\n\t\t\t$matchKey_val2 = `keyframe -time $matchKey2 -q -valueChange $channel`;\n\t\t\t$firstKey_val2 = `keyframe -time $firstKey2 -q -valueChange $channel`;\n\t\t\t$delta2 = $matchKey_val2[0] - $firstKey_val2[0];\n\t\t\t//////////////////////////\n///////////////////////////////////////////////////////snaptotime a+f1/c+f1\n\t\t\tfloat $allseleKeys[] = sort(`keyframe -q -sl`);\n\t\t\t$Frame_a = $allseleKeys[0];\n\t\t\t$Frame_b = $allseleKeys[(size($allseleKeys) -1)];\n\t\t\t$curTime = `currentTime -q`;\n\t\t\t$deltasnaptotime = $curTime - $Frame_a;\n\t\t\t$deltasnaptotime2 = $curTime - $Frame_b;\n\t\t\tif ($cmd == \"leftsnaptotime\"){\n\t\t\t\tkeyframe -relative -o over -timeChange $deltasnaptotime;\n\t\t\t}else if ($cmd == \"rightsnaptotime\"){\n\t\t\t\tkeyframe -relative -o over -timeChange $deltasnaptotime2;\n\t\t\t}\n///////////////////////////////////////////////////////\n\t\t\t//AAAAA scale selected keys\n\t\t\t$selected = `keyframe -selected -q -indexValue $channel`;\n\t\t\tfor ($i = 0; $i < size($selected); $i++){\n///////////////////////////////////////////////////////xu zhi ding \"$ackSetup_pivot\"\n\t\t\t\tif ($cmd == \"push\"){\n\t\t\t\t\tscaleKey -index $selected[$i] -valuePivot $pivotValue[0] -valueScale (1/$ackSetup_scaleFactor) $channel;\n\t\t\t\t}else if ($cmd == \"pull\"){\n\t\t\t\t\tscaleKey -index $selected[$i] -valuePivot $pivotValue[0] -valueScale ($ackSetup_scaleFactor) $channel;\n\t\t\t\t////////\n\t\t\t\t}else if ($cmd == \"pushhalf\"){\n\t\t\t\t\tscaleKey -index $selected[$i] -valuePivot $pivotValue[0] -valueScale (1/$ackSetup_scaleFactor-0.09) $channel;\n\t\t\t\t}else if ($cmd == \"pullhalf\"){\n\t\t\t\t\tscaleKey -index $selected[$i] -valuePivot $pivotValue[0] -valueScale ($ackSetup_scaleFactor+0.09) $channel;\n\t\t\t\t////////\n\t\t\t\t}else if ($cmd == \"fanzhuan\"){\n\t\t\t\t\tscaleKey -index $selected[$i] -valuePivot $pivotValue[0] -valueScale -1 $channel;\n///////////////////////////////////////////////////////\n///////////////////////////////////////////////////////zhi jie shi yong\n\t\t\t\t}else if ($cmd == \"swell\"){\n\t\t\t\t\tscaleKey -index $selected[$i] -valuePivot 0 -valueScale (1/$ackSetup_scaleFactor) $channel;\n\t\t\t\t}else if ($cmd == \"shrink\"){\n\t\t\t\t\tscaleKey -index $selected[$i] -valuePivot 0 -valueScale ($ackSetup_scaleFactor) $channel;\n\t\t\t\t//////\n\t\t\t\t}else if ($cmd == \"fanX\"){\n\t\t\t\t\tscaleKey -index $selected[$i] -valuePivot 0 -valueScale -1 $channel;\n\t\t\t\t}else if ($cmd == \"fanY\"){\n\t\t\t\t\tscaleKey -index $selected[$i] -timeScale -1 -valuePivot 0 -valueScale 1 $channel;\n///////////////////////////////////////////////////////snap\n\t\t\t\t}else if ($cmd == \"leftsnap\"){\n\t\t\t\t\tkeyframe -relative -index $selected[$i] -valueChange $delta $channel;\n\t\t\t\t}else if ($cmd == \"rightsnap\"){\n\t\t\t\t\tkeyframe -relative -index $selected[$i] -valueChange $delta2 $channel;\n///////////////////////////////////////////////////////key-fanzhuan\n\t\t\t\t}else if ($cmd == \"lrfanzhuan\"){\n\t\t\t\t\tscaleKey -timeScale -1 -timePivot (($Frame_a+$Frame_b)/2);\n\t\t\t\t}\n///////////////////////////////////////////////////////\n\t\t\t}//close AAAAA\n\t\t}\t//loop curves\n\t}\t//chk key selection\n}\n/////////////////////////////\n//***************************\n/////////////////////////////\nglobal proc ackMoveKeys (string $cmd){\n\t//only run if at least one key is selected\n\t$keyCount = `keyframe -an keys -q -keyframeCount`;\n\tif ($keyCount != 0) {\n\t\tif ($cmd == \"left\"){\n\t\t\tkeyframe -animation keys -option over -relative -timeChange -1;\n\t\t} else if ($cmd == \"right\"){\n\t\t\tkeyframe -animation keys -option over -relative -timeChange 1;\n\t\t} else {\t\t\t\n\t\t\tglobal float $ackSetup_fixedFactor;\n\t\t\tglobal float $ackSetup_scaleFactor;\n\t\t\tglobal string $ackSetup_autoTangent;\n\n\t\t\t//set default value if doesn't exist\n\t\t\tif ($ackSetup_fixedFactor <= .000001){\n\t\t\t\t$ackSetup_fixedFactor = .05;\n\t\t\t}\n\t\t\tif ($ackSetup_scaleFactor <= .000001){\n\t\t\t\t$ackSetup_scaleFactor = .9;\n\t\t\t}\n\t\t\tif ($ackSetup_autoTangent == \"\"){\n\t\t\t\t$ackSetup_autoTangent = \"true\";\n\t\t\t}\n\n\n\t\t\t///// Up and Down ////\n\t\t\tif ($cmd == \"up\" || $cmd == \"down\"){\n\n\t\t\t\t//loop over selected curves and process independently\n\t\t\t\tstring $selectedCurves[] = `keyframe -selected -q -name`;\n\t\t\t\tfor ($c = 0; $c < size($selectedCurves); $c++){\n\t\t\t\t\t//channel to use for this pass\n\t\t\t\t\t$channel = $selectedCurves[$c];\n\n\t\t\t\t\t//GET MOVE SCALE BASED OFF NEIGHBORING KEYS\n\t\t\t\t\t//get first and last keys in selection by index\n\t\t\t\t\tint $firstKey;\n\t\t\t\t\tint $lastKey;\n\t\t\t\t\t$totalKeys = `keyframe -q -keyframeCount $channel`;\n\t\t\t\t\t$selectedIndices = `keyframe -selected -q -indexValue $channel`;\n\n\t\t\t\t\t//get adjacent keys to selection\n\t\t\t\t\tint $prevKey = $selectedIndices[0] - 1;\n\t\t\t\t\tint $nextKey = $selectedIndices[size($selectedIndices)-1] + 1;\n\n\t\t\t\t\t//if first or last key, use itself\n\t\t\t\t\tif ($prevKey == -1){\n\t\t\t\t\t\t$prevKey = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif ($nextKey == $totalKeys){\n\t\t\t\t\t\t$nextKey = $totalKeys - 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t//get values of adjacent keys\n\t\t\t\t\tfloat $prevKeyValue[] = `keyframe -index $prevKey -q -valueChange $channel`;\n\t\t\t\t\tfloat $nextKeyValue[] = `keyframe -index $nextKey -q -valueChange $channel`;\n\n\t\t\t\t\t//get delta for move calc\n\t\t\t\t\tfloat $delta = $nextKeyValue[0] - $prevKeyValue[0];\n\n\t\t\t\t\t//case when delta is 0: just use factor\n\t\t\t\t\tif ($delta == 0){\n\t\t\t\t\t\t$delta = $ackSetup_fixedFactor*10;\n\t\t\t\t\t}\n\n\t\t\t\t\t//get move direction (reverse if key is on downslope);\n\t\t\t\t\tint $moveDir = sign($delta);\n\n\t\t\t\t\t//DO THE MOVE\n\t\t\t\t\t$selected = `keyframe -selected -q -indexValue $channel`;\n\t\t\t\t\tswitch ($cmd) {\n\t\t\t\t\t\tcase \"up\":\t\t\t\t\n\t\t\t\t\t\t\tfor ($i = 0; $i < size($selected); $i++){\n\t\t\t\t\t\t\t\tkeyframe -relative -index $selected[$i] -valueChange ($delta * $ackSetup_fixedFactor * $moveDir) $channel;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase \"down\":\n\t\t\t\t\t\t\tfor ($i = 0; $i < size($selected); $i++){\n\t\t\t\t\t\t\t\tkeyframe -relative -index $selected[$i] -valueChange ($delta * $ackSetup_fixedFactor * $moveDir * -1) $channel;\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}//end for - loop over curves\n\t\t\t///// ConvergeLeft and ConvergeRight ////\n\t\t\t} else if ($cmd == \"convergeLeft\" || $cmd == \"convergeRight\"){\n\t\t\t\n\t\t\t\t//loop over selected curves and process independently\n\t\t\t\tstring $selectedCurves[] = `keyframe -selected -q -name`;\n\t\t\t\tfor ($c = 0; $c < size($selectedCurves); $c++){\n\t\t\t\t\t//channel to use for this pass\n\t\t\t\t\t$channel = $selectedCurves[$c];\n\n\t\t\t\t\t//get array of key times in selection (to find closest match key)\n\t\t\t\t\t$timeArray = `keyframe -selected -q -timeChange $channel`;\n\n\t\t\t\t\t//get pivot point\n\n\t\t\t\t\tswitch ($cmd){\n\t\t\t\t\t\tcase \"convergeLeft\":\n\t\t\t\t\t\t\t$pivotTime = `findKeyframe -which \"previous\" -time $timeArray[0] $channel`;\n\t\t\t\t\t\t\t$pivotValue = `keyframe -time $pivotTime -q -valueChange $channel`;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase \"convergeRight\":\n\t\t\t\t\t\t\tint $lastKey = size($timeArray) - 1;\n\t\t\t\t\t\t\t$pivotTime = `findKeyframe -which \"next\" -time $timeArray[$lastKey] $channel`;\n\t\t\t\t\t\t\t$pivotValue = `keyframe -time $pivotTime -q -valueChange $channel`;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\n\t\t\t\t\t//scale selected keys\n\t\t\t\t\t$selected = `keyframe -selected -q -indexValue $channel`;\n\t\t\t\t\tfor ($i = 0; $i < size($selected); $i++){\n\t\t\t\t\t\tscaleKey -index $selected[$i] -valuePivot $pivotValue[0] -valueScale ($ackSetup_scaleFactor) $channel;\n\t\t\t\t\t}\n\t\t\t\t}\t//loop curves\t\t\t\n\t\t\t}//end switch between up/down and converges\n\t\t\t\n\t\t\t//auto tangent result if flag is set\n\t\t\t/*\n\t\t\tif ($ackSetup_autoTangent == \"true\"){\n\t\t\t\tstring $tang[] =`keyTangent -q -ott`;\n\t\t\t\tif ($tang[0] != \"step\"){\n\t    \t\t\tautoTangent();\n\t   \t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t}//end $cmd argument\n\t}//end chk for > 0 keys selected\n}" 
        -optionBox 0
        -enable 1
        -visible 1
        -data 0
        -radialPosition "SW" 
        -allowOptionBoxes 1
        -postMenuCommandOnce 0
        -enableCommandRepeat 1
        -echoCommand 0
        -italicized 0
        -boldFont 1
        -sourceType "mel" 
        -longDivider 1
        menuEditorMenuItem5;

    mennuu
        -label "menuEditorMenuItem19" 
        -divider 0
        -subMenu 0
        -tearOff 0
        -command "global proc acktooluse(int $shu){//$LorR 0=left /1=right /2=wu \nglobal string $ackSetup_pivot;\nswitch($shu){\n\tcase 1 ://.||\n\t\t$ackSetup_pivot = \"left\";ackPushPull \"fanzhuan\";\n\tbreak;\n\tcase 7://F1\n\t\t$ackSetup_pivot = \"left\";ackPushPull \"pull\";\n\tbreak;\n\tcase 8://F2\n\t\t$ackSetup_pivot = \"left\";ackPushPull \"push\";\n\tbreak;\t\n\tcase 11://o-f1-o\n\t\t$ackSetup_pivot = \"left\";ackPushPull \"pullhalf\";\n\tbreak;\n\tcase 12://o-f2-o\n\t\t$ackSetup_pivot = \"left\";ackPushPull \"pushhalf\";\n\tbreak;\n\t}\nswitch($shu){\n\tcase 2 ://||.\n\t\t$ackSetup_pivot = \"right\";ackPushPull \"fanzhuan\";\n\tbreak;\n\tcase 9://F3\n\t\t$ackSetup_pivot = \"right\";ackPushPull \"push\";\n\tbreak;\n\tcase 10://F4\n\t\t$ackSetup_pivot = \"right\";ackPushPull \"pull\";\n\tbreak;\n\tcase 13://o-f3-o\n\t\t$ackSetup_pivot = \"right\";ackPushPull \"pushhalf\";\n\tbreak;\n\tcase 14://o-f4-o\n\t\t$ackSetup_pivot = \"right\";ackPushPull \"pullhalf\";\n\tbreak;\n\t}\nswitch($shu){\n\tcase 20://|X|\n\t\tackPushPull \"fanX\";\n\tbreak;\n\tcase 21://|Y|\n\t\tackPushPull \"fanY\";\n\tbreak;\n\tcase 22://snapL\n\t\tackPushPull \"leftsnap\";\n\tbreak;\n\tcase 23://snapR\n\t\tackPushPull \"rightsnap\";\n\tbreak;\n\tcase 24://a+f1\n\t\tackPushPull \"leftsnaptotime\";\n\tbreak;\n\tcase 25://c+f1\n\t\tackPushPull \"rightsnaptotime\";\n\tbreak;\n\tcase 26://c+f\n\t\tackPushPull \"swell\";\n\tbreak;\n\tcase 27://a+f2\n\t\tackPushPull \"shrink\";\n\tbreak;\n\tcase 28://|<>|\n\t\tackPushPull \"lrfanzhuan\";\n\tbreak;\n\t}\n}//acktooluse(2);" 
        -optionBox 1
        -enable 1
        -visible 0
        -data 0
        -allowOptionBoxes 1
        -postMenuCommandOnce 0
        -enableCommandRepeat 0
        -echoCommand 0
        -italicized 0
        -boldFont 1
        -sourceType "mel" 
        -longDivider 1
        menuEditorMenuItem19;

    mennuu
        -label "keysmoothGO(+-*)" 
        -divider 0
        -subMenu 0
        -tearOff 0
        -command "global proc keysmoothGO(float $O){//0.2>pinghua -0.2>jiada\n\tstring $aniCurveList[]=`keyframe -q -sl -name`;\n\tfor($curve in $aniCurveList){\n\t\tint   $select_indexList[]  = `keyframe -sl -q -indexValue  $curve`;\n\t\tfloat $select_timeList[]   = `keyframe -sl -q -timeChange  $curve`;\n\t\tfloat $select_valueList[]  = `keyframe -sl -q -valueChange $curve`;\n\t\tint   $all_indexList[]  = `keyframe -q -indexValue  $curve`;\n\t\tfloat $all_timeList[]   = `keyframe -q -timeChange  $curve` ;\n\t\tfloat $all_valList[]    = `keyframe -q -valueChange $curve`;\n\t\tfor($j=0; $j < (size($select_indexList)); $j++){\n\t\t\tint $selIndex = $select_indexList[$j];\n\t\t\tif($selIndex == 0)continue;\n\t\t\tif($selIndex == $all_indexList[size($all_indexList)-1])continue;\n\t\t\t\tfloat $nowVal    = $all_valList[$selIndex];\n\t\t\t\tfloat $beforeVal = $all_valList[$selIndex-1];\n\t\t\t\tfloat $afterVal  = $all_valList[$selIndex+1];\n\t\t\t\tint $nowTime     = $all_timeList[$selIndex];\n\t\t\t\tint $beforeTime  = $all_timeList[$selIndex-1];\n\t\t\t\tint $afterTime   = $all_timeList[$selIndex+1];\n\t\t\t\tfloat $ratio = ($nowTime-$beforeTime)/(($afterTime-$beforeTime)*1.0);\n\t\t\t\tfloat $aveVal = $beforeVal+(($afterVal-$beforeVal) * $ratio);\n\t\t\t\tfloat $setVal = $nowVal -  (($nowVal - $aveVal) * $O);\n\t\t\t\tkeyframe -e -index $selIndex -valueChange $setVal  $curve;\n\t\t}\n\t}\n}//keysmoothGO(-0.2)" 
        -optionBox 0
        -enable 1
        -visible 1
        -data 0
        -radialPosition "S" 
        -allowOptionBoxes 1
        -postMenuCommandOnce 0
        -enableCommandRepeat 1
        -echoCommand 0
        -italicized 0
        -boldFont 1
        -sourceType "mel" 
        -longDivider 1
        menuEditorMenuItem8;

    mennuu
        -label "QuickConsW" 
        -divider 0
        -subMenu 0
        -tearOff 0
        -command "global proc SP_QuickCons(){\nif(`window -ex SP_QuickConsWindow`) deleteUI SP_QuickConsWindow;\nwindow -title \"SP_QuickCons\" SP_QuickConsWindow;\ncolumnLayout -adjustableColumn true;\nrowLayout -nc 6;\nbutton -w 30 -l \"moto\" -c QA_pickOrigin -ann \"QA_pickOrigin\";\nbutton -w 30 -l \"saki\" -c QA_pickTarget -ann \"QA_pickTarget\";\nbutton -w 30 -l \"check\" -c \"QA_listCheck;newhelp;\" ;\nsetParent..;\nrowLayout -nc 10;\nbutton -w 30 -l \"A\" -c \"select $A\";\nbutton -w 30 -l \"B\" -c \"select $B\";\nbutton -w 30 -l \"A+B\" -c \"select $A $B;\";\nbutton -w 30 -l \"B+A\" -c \"select $B $A;\";\nsetParent..;\nrowLayout -nc 10;\nbutton -w 30 -l \"P>\" -c \"QAapllycon(0,0)\" -ann \"A>B pcon\";\nbutton -w 30 -l \"<P\" -c \"QAapllycon(1,0)\" -ann \"A<B pcon\";\nbutton -w 30 -l \"O>\" -c \"QAapllycon(0,1)\" -ann \"A>B ocon\";\nbutton -w 30 -l \"<O\" -c \"QAapllycon(1,1)\" -ann \"A<B ocon\";\nsetParent..;\n\ntext -label \".\";\nrowLayout -nc 3;\nbutton -h 16 -l \"+oya group\" -c GetFormGroup1 -ann \"+oya group  (GetFormGroup1)\";\nbutton -h 16 -l \"+ko group\" -c GetFormGroup2 -ann \"+ko group  (GetFormGroup2)\";\nsetParent ..;\n\ntext -label \".\";\nrowLayout -nc 3;\nbutton -h 16 -l \"X>newX\" -c GetFormLocator2 -ann \"add lot  (GetFormLocator2)\";\nbutton -h 16 -l \"-->+parent \" -c GetFormLocator3 -ann \"add lot>parent (GetFormLocator3)\";\nsetParent..;\nrowLayout -nc 3;\nbutton -h 16 -l \"XY..>newXY..+con\" -c addlot -ann \"(addlot)\";\nbutton -h 16 -l \"newXY..+con+bake\" -c addlotbake -ann \"(addlotbake)\";\nsetParent..;\n\ntext -label \".\";\nrowLayout -nc 3;\nbutton -h 16 -l \"xyz..>x(.)y\" -c originnone -ann \"X+YZ>X(x)+Y (originnone)\";\nbutton -h 16 -l \"->yz..>con\" -c duochongaddcon2 -ann \"X+YZ>X(x)+Y    +(x)poYZ> (duochongaddcon2)\";\nsetParent ..;\n\ntext -label \".\";\nrowLayout -nc 3;\nbutton -h 16 -l \"xyz..>newx(.)+yz..>con\" -c duochongaddcon1 -ann \"+tishen +offset +POcon  (duochongaddcon1)\";\nsetParent ..;\nrowLayout -nc 1;\nbutton -h 16 -l \"|-->+bake\" -c addbake -ann \"+bake,shan gomi  (addbake)\";\nsetParent ..;\n\ntext -label \".\";\nrowLayout -nc 1;\nbutton -h 16 -l \"X+YZ>X(xxx)+YZ..AIcon\" -c duochongaddcon3 -ann \"X+YZ>X(xxx)+YZ..AIcon (duochongaddcon3)\";\nsetParent ..;\n\n\ntext -label \".\";\nrowLayout -nc 10;\nbutton -l \"P\" -c \"putongcon(0)\" -ann \"putongcon(0)\";\nbutton -l \"P.\" -c \"putongcon(1)\" -ann \"putongcon(1)\";\nbutton -l \"O\" -c \"putongcon(10)\" -ann \"putongcon(10)\";\nbutton -l \"O.\" -c \"putongcon(11)\" -ann \"putongcon(11)\";\nbutton -l \"AIP\" -c AIPcon;\nbutton -l \"AIO\" -c AIOcon;\nsetParent ..;\nrowLayout -nc 4;\nbutton -l \"conmubiao\" -c foundconmubiao;\nbutton -l \"consaki\" -c foundconsaki;\nsetParent ..;\nrowLayout -nc 3;\nbutton -l \"beizhu_P\" -c \"beizhu(1)\";\nbutton -l \"->O\" -c \"beizhu(2)\";\nbutton -l \"->PO\" -c \"beizhu(3)\";\nsetParent ..;\n\nrowLayout -nc 2;\nbutton -l \"fancon_1f\" -c \"fancon(1)\";\nbutton -l \"->mm\" -c \"fancon(2)\";\nsetParent ..;\n\nrowLayout -nc 2;\nbutton -l \"xy.+z>duochongP\" -c \"duochongcon(1)\" -ann \"duochongcon(1) xxxxxxxxxxxxxxxxxxxxxxxxxxx\";\nbutton -l \"->O\" -c \"duochongcon(2)\";\nsetParent ..;\nrowLayout -nc 4;\nbutton -l \"match(con)P\" -c \"conmatch(1)\";\nbutton -l \"O\" -c \"conmatch(2)\";\nbutton -l \"S\" -c \"conmatch(3)\";\nbutton -l \"POS\" -c \"conmatch(5)\";\nsetParent ..;\n\nshowWindow;\nwindow -e -h 100 -w 100 SP_QuickConsWindow;\n}//SP_QuickCons;\n//-//-//-//-//-//\n//-//-//-//-//-//\n//-//-//-//-//-//\n//-//-//-//-//-//\n//con moto sel>go\nglobal proc QA_pickOrigin(){\nglobal string $A[];\n\t$A=`ls-sl`;\n\tprint $A;\n}\n//-//-//-//-//-//\n//con saki sel>go\nglobal proc QA_pickTarget(){\nglobal string $B[];\n\t$B=`ls-sl`;\n\tprint $B;\n}\n//-//-//-//-//-//\nglobal proc QA_listCheck(){//xxxxxxxxxxxxxxxxx\nglobal string $A[];\nglobal string $B[];\nint $Asize=`size($A)`;\nint $Bsize=`size($B)`;\n\tint $cnt =0;\n\tprint \"XXxxxxxxxxxxxxxX\\n\";\n    print (\"A\"+$Asize);\n    print (\"---B\"+$Bsize+\"\\n\");\n\tfor ($val in $A){\n\t\tprint $A[$cnt];\n\t\tprint \" <> \";\n\t\tprint $B[$cnt];\n\t\tprint \"\\n\";\n\t\t$cnt++;\n\t}\n}\n//\nglobal proc newhelp(){\nwindow -title \"ss\";\n    columnLayout;\n        cmdScrollFieldReporter -width 400 -height 400;\nshowWindow;\n}\n//-//-//-//-//-//\n//-//-//-//-//-////<A>B POcon\nglobal proc QAapllycon(int $abba,int $po){\t\nglobal string $A[];\nglobal string $B[];\t\nint $cc=0;\nfor($val in $A){\n    if($abba==0&&$po==0){pointConstraint -n \"_conXiaoJie\" $A[$cc] $B[$cc];}\n    if($abba==1&&$po==0){pointConstraint -n \"_conXiaoJie\" $B[$cc] $A[$cc];}\n    \n    if($abba==0&&$po==1){orientConstraint -n \"_conXiaoJie\" $A[$cc] $B[$cc];}\n    if($abba==1&&$po==1){orientConstraint -n \"_conXiaoJie\" $B[$cc] $A[$cc];}\n    $cc++;\n}\n}\n//-//-//-//-//-//\n//-//-//-//-//-//PuTong縲?con 譛穎ame\nglobal proc putongcon(int $ding){// 0-1 Pcon 10-11 Ocon \nstring $allsele[]=`ls-sl`;\nfor($x=1;$x<`size($allsele)`;$x++){\nif($ding==0){pointConstraint -n \"_conXiaoJie\" $allsele[0] $allsele[$x];}\nelse if($ding==1){pointConstraint -mo -n \"_conXiaoJie\" $allsele[0] $allsele[$x];}\n//\nelse if($ding==10){orientConstraint -n \"_conXiaoJie\" $allsele[0] $allsele[$x];}\nelse if($ding==11){orientConstraint -mo -n \"_conXiaoJie\" $allsele[0] $allsele[$x];}\n}\n}\n//-//-//-//-//-//\n//-//-//-//-//-//\nglobal proc conmatch(int $pos){//1>P 2>O 3>S 5>POS\nif(size(`ls-sl`)==2){\nif($pos==1){pointConstraint -n \"naze\" -offset 0 0 0 -weight 1;}\nelse if($pos==2){orientConstraint -n \"naze\" -offset 0 0 0 -weight 1;}\nelse if($pos==3){scaleConstraint -n \"naze\" -offset 1 1 1 -weight 1;}\nelse if($pos==5){\npointConstraint -n \"naze\" -offset 0 0 0 -weight 1;\norientConstraint -n \"naze\" -offset 0 0 0 -weight 1;\nscaleConstraint -n \"naze\" -offset 1 1 1 -weight 1;}\ndelete \"naze*\";//DeleteConstraints;\n}}//conmatch(1)\n//-//-//-//-//-//\n//-//-//-//-//-//\nglobal proc GetFormLocator(){//蠎ｧ讓吝ｸｰ0蠑・\n    string $selerig[] = `ls-sl`;\n    int $Josize =`size($selerig)`;\n    string $newlot[];\n    int $x;\n    for ($x = 0;$x < $Josize; $x++){\n        float $t[] = `xform -a -q -ws -t $selerig[$x]`;\n        float $r[] = `xform -a -q -ws -ro $selerig[$x]`;\n        spaceLocator -a;\n        //rename (\"Form_\" + $Jo[$x]);\n        string $namae =  $selerig[$x] + \"Form_\" ;\n        rename $namae ;\n        xform -ws -t $t[0] $t[1] $t[2];\n        xform -ws -ro $r[0] $r[1] $r[2]; \n        //group -n \"Form\" ;\n        string $LoTest[] = `ls -sl`;\n        $newlot[$x] = $LoTest[0]; \n    }\n    select -r $newlot;\n    //xform -ws -piv 0 0 0;\n}\n//-//-//-//-//-//\n//-//-//-//-//-//\nglobal proc GetFormLocator2(){//+con-con蠑・\nstring $selerig[]=`ls-sl`;\nstring $newlot[];\nfor ($x=0;$x<`size($selerig)`;$x++){\nspaceLocator;\nrename ($selerig[$x]+\"Form_\");\nstring $new[]=`ls-sl`;\nselect -tgl $selerig[$x];sunxujiaohuan;\nconmatch(1);conmatch(2);\n$newlot[$x]=$new[0]; \n}select -r $newlot;\n}\n//-//-//-//-//-//\n//-//-//-//-//-//\nglobal proc GetFormLocator3(){//+ko lot\nstring $seleobj[]=`ls-sl`;\nfor($x=0;$x<`size($seleobj)`;$x++){\nselect $seleobj[$x];\nGetFormLocator2;\nselect -tgl $seleobj[$x];\nparent;rename ($seleobj[$x]+\"_L\");\n}\n}\n//-//-//-//-//-//\nglobal proc GetFormLocator4(){//gennten+lot \nstring $seleobj[]=`ls-sl`;\nfor($x=0;$x<`size($seleobj)`;$x++){\nspaceLocator -p 0 0 0;\nrename \"GenntenLot\";\noutlinecolor(101); \nselect -tgl $seleobj[$x];\nduochongaddcon2;\n}\n}\n//-//-//-//-//-//\nglobal proc addlot(){//X>newX +con\nfor($work in `ls -sl`){ \nselect $work;\nGetFormLocator2;\nselect -tgl $work;\nsunxujiaohuan;\nputongcon(0);putongcon(10);\n}danxuanlast;\n}\n//-//-//-//-//-//\nglobal proc addlotbake(){//addlot+bake\nstring $selerig[]=`ls-sl`;\nstring $newlots[];\nfor($g=0;$g<size($selerig);$g++){\nselect $selerig[$g];\naddlot;\nsonbakeTO;\noutlinecolor(100);\nstring $sss[]=`ls-sl`;\n$newlots[$g]=$sss[0];\nfoundconmubiao;\ndelete;\n}select $newlots;\n}\n//-//-//-//-//-//\n//-//-//-//-//-//\nglobal proc GetFormGroup1(){\nfor($a in `ls-sl`){\nselect $a;\ndoGroup 0 1 0;\nrename ($a+\"_D\");\n}\n}\n//-//-//-//-//-//\n//-//-//-//-//-//\nglobal proc GetFormGroup2(){\nfor($a in `ls-sl`){\nselect $a;\nCreateEmptyGroup;\nselect -tgl $a;parent;\nCurveOperation Tzero;\nCurveOperation Rzero;\nCurveOperation Szero;\n}\n}\n//-//-//-//-//-//\n//-//-//-//-//-//\nglobal proc originnone(){//xyz..>x(offset)yz..\nif(size(`ls-sl`)!=0){\nstring $bianzhongcon[]=`ls-sl`;\ndanxuanfast;GetFormGroup2;\nrename ($bianzhongcon[0]+\"_OyaXiaoJie\");\nstring $newoyao[]=`ls-sl`;\nselect $bianzhongcon[1] $newoyao;\nconmatch(1);conmatch(2);\nselect $newoyao $bianzhongcon[1];\n}\n}\n//-//-//-//-//-//\n//-//-//-//-//-//\nglobal proc duochongaddcon1(){//xyz..>new(x)yz..>con\nstring $addlotrig[] = `ls-sl`;\nint $rigsize =`size($addlotrig)`;\ndanxuanfast;addlot;\nstring $Oyaa[] = `ls-sl`;\nfor ($x = 1;$x < $rigsize; $x++){\nselect $Oyaa $addlotrig[$x];\noriginnone;\nputongcon(0);putongcon(10);\n}\n}\n//-//-//-//-//-//\n//-//-//-//-//-//\nglobal proc duochongaddcon2(){//xyz..>x(offset)yz..>con \nstring $selectrig[]=`ls -sl`;\nint $Josize =`size($selectrig)`;\nfor ($x = 1;$x < $Josize; $x++){\nint $tagetT = `getAttr -lock ($selectrig[$x] + \".tx\")`;\nint $tagetR = `getAttr -lock ($selectrig[$x] + \".rx\")`;\n\nselect $selectrig[0] $selectrig[$x];\noriginnone;\nif ($tagetT==0){\nputongcon(0);\n}\nif ($tagetR==0){\nputongcon(10);\n}\n}\n}\n//-//-//-//-//-//\n//-//-//-//-//-//\nglobal proc addbake(){\nstring $selerig[] = `ls-sl`; \nint $shuliang =`size($selerig)`;\nif ($shuliang == 1){\naddlotbake;\n}else if ($shuliang == 2){\nduochongaddcon1;\nselect $selerig[1];\nfoundconsaki;pickWalk -d up;\nstring $selerig2[] = `ls-sl`;\nselect $selerig[1];\nsonbakeTO;\ndelete $selerig2;\n}\n}\n//-//-//-//-//-//\n//-//-//-//-//-//\n//http://hossanmayamel.blogspot.jp/2015/02/mel.html\nglobal proc REVERSE_CONSTRAINT(){\ndanxuanfast;string $xx[]=`ls-sl`;\nstring $parentConstraint_LIST[] = `parentConstraint -q -tl`;\nstring $pointConstraint_LIST[] = `pointConstraint -q -tl`;\nstring $orientConstraint_LIST[] = `orientConstraint -q -tl`;\nstring $scaleConstraint_LIST[] = `scaleConstraint -q -tl`; \nstring $TARGET_NODE;          \nif(size($parentConstraint_LIST)>0){\n\tfor($TARGET_NODE in $parentConstraint_LIST){\n\t\tselect -add $TARGET_NODE;\n\t}\n}\nif(size($pointConstraint_LIST)>0){\n\tfor($TARGET_NODE in $pointConstraint_LIST){\n\t\tselect -add $TARGET_NODE;\n\t}\n}\nif(size($orientConstraint_LIST)>0){\n\tfor($TARGET_NODE in $orientConstraint_LIST){\n\t\tselect -add $TARGET_NODE;\n\t}\n}\nif(size($scaleConstraint_LIST)>0){\n\tfor($TARGET_NODE in $scaleConstraint_LIST){\n\t\tselect -add $TARGET_NODE;\n\t}\n}\nselect -d $xx;\n}\n//-//-//-//-//-//zhineng hua\nglobal proc AIPcon(){\nstring $twoselect[]=`ls -sl`;\nint $panduanTx = `getAttr -lock ($twoselect[1] + \".tx\")`;\nint $panduanTy = `getAttr -lock ($twoselect[1] + \".ty\")`;\nint $panduanTz = `getAttr -lock ($twoselect[1] + \".tz\")`;\nstring $EVAL_STRING = \"pointConstraint -weight 1\";\nif($panduanTx == 1) $EVAL_STRING = $EVAL_STRING + \" -sk x\";\nif($panduanTy == 1) $EVAL_STRING = $EVAL_STRING + \" -sk y\";\nif($panduanTz == 1) $EVAL_STRING = $EVAL_STRING + \" -sk z\";\n$EVAL_STRING = $EVAL_STRING + \" \" + $twoselect[0] + \" \" + $twoselect[1] + \";\";\neval $EVAL_STRING;\n}\n///////\nglobal proc AIOcon(){\nstring $twoselect[]=`ls -sl`;\nint $panduanRx = `getAttr -lock ($twoselect[1] + \".rx\")`;\nint $panduanRy = `getAttr -lock ($twoselect[1] + \".ry\")`;\nint $panduanRz = `getAttr -lock ($twoselect[1] + \".rz\")`;\nstring $EVAL_STRING = \"orientConstraint -weight 1\";\nif($panduanRx == 1) $EVAL_STRING = $EVAL_STRING + \" -sk x\";\nif($panduanRy == 1) $EVAL_STRING = $EVAL_STRING + \" -sk y\";\nif($panduanRz == 1) $EVAL_STRING = $EVAL_STRING + \" -sk z\";\n$EVAL_STRING = $EVAL_STRING + \" \" + $twoselect[0] + \" \" + $twoselect[1] + \";\";\neval $EVAL_STRING;\n}\n//-//-//-//-//-//\nglobal proc beizhu(int $po){//P=pcon O=ocon PO=pocon\nstring $nima[]=`ls-sl`;\nif($po==\"1\"){conmatch(1);sunxujiaohuan;AIPcon;}\nif($po==\"2\"){conmatch(2);sunxujiaohuan;AIOcon;}\nif($po==\"3\"){\nconmatch(1);conmatch(2);sunxujiaohuan;\nAIPcon;AIOcon;}\nselect $nima;//[0];\n}\n//-//-//-//-//-//\nglobal proc duochongcon(int $po){\nstring $duoselobj[]=`ls-sl`;\nint $shu=size($duoselobj);\nfor($a=0;$a<$shu-1;$a++){\nif($po==\"1\"){pointConstraint $duoselobj[$a] $duoselobj[$shu-1];}\nif($po==\"2\"){orientConstraint $duoselobj[$a] $duoselobj[$shu-1];}\n}\n}\n//-//-//-//-//-//\nglobal proc fancon(int $oneormm){//1>1f 2>mm\nstring $fanselobj[]=`ls-sl`;\nint $fanselshu=size($fanselobj);\n\tfor ($x = 0;$x < $fanselshu; $x++){\n\t\tselect $fanselobj[$x];\n\t\tstring $parentConstraint_LIST[] = `parentConstraint -q -tl`;\n\t\tstring $pointConstraint_LIST[] = `pointConstraint -q -tl`;\n\t\tstring $orientConstraint_LIST[] = `orientConstraint -q -tl`;     \n\t\tstring $TARGET_NODE;          \n\t\tif(size($parentConstraint_LIST)>0){\n\t\t\tfor($TARGET_NODE in $parentConstraint_LIST){\n\t\t\t    if($oneormm==1){\n\t\t\t    \tparentConstraint -remove $TARGET_NODE $fanselobj[$x];\n\t\t\t    \tparentConstraint $fanselobj[$x] $TARGET_NODE;\n\t\t\t\t}else if($oneormm==2){\n\t\t\t\t    select $fanselobj[$x];\n\t\t\t\t    sonbakeTO;\n\t\t\t\t    parentConstraint $fanselobj[$x] $TARGET_NODE;\n\t\t\t\t}\n\t\t\t}print \"parent\";\n\t\t}\n\t\tif(size($pointConstraint_LIST)>0){\n\t\t\tfor($TARGET_NODE in $pointConstraint_LIST){\n\t\t\t    if($oneormm==1){\n\t\t\t    \tpointConstraint -remove $TARGET_NODE $fanselobj[$x];\n\t\t\t    \tselect $fanselobj[$x] $TARGET_NODE;AIPcon;\n\t\t\t\t}else if($oneormm==2){\n\t\t    \t\tselect $fanselobj[$x];\n\t\t\t    \tsonbakeT;\n\t\t\t    \tselect $fanselobj[$x] $TARGET_NODE;AIPcon;\n\t\t\t    }\n\t\t\t}print \"point\";\n\t\t}\n\t\tif(size($orientConstraint_LIST)>0){\n\t\t\tfor($TARGET_NODE in $orientConstraint_LIST){\n\t\t\t    if($oneormm==1){\n\t\t\t    \torientConstraint -remove $TARGET_NODE $fanselobj[$x];\n\t\t\t    \tselect $fanselobj[$x] $TARGET_NODE;AIOcon;\n\t\t\t\t}else if($oneormm==2){\n\t\t    \t\tselect $fanselobj[$x];\n\t\t\t    \tsonbakeO;\n\t\t    \t\tselect $fanselobj[$x] $TARGET_NODE;AIOcon;\n\t\t    \t}\n\t\t\t}print \"orient\";\n\t\t}\n\t}\n}\n//-//-//-//-//-//\nglobal proc foundconsaki(){\nif(size(`ls-sl`)!=0){\nstring $selectobj[]=`ls-sl`;\nstring $sakiobj2[];\nint $x = 0;\nfor($work in `ls -sl`){\nselect $work;\nREVERSE_CONSTRAINT;\nif(size(`ls-sl`)==0){\n select $selectobj;\n}else{\nstring $sakiobj[] = `ls-sl`;\n$sakiobj2[$x] = $sakiobj[0]; \n$x++;\nselect $sakiobj2;\n}\n}}print \"zhao con tou\";\n}\n//-//-//-//-//-//\nglobal proc foundconmubiao(){\nif(size(`ls-sl`)!=0){\nstring $lists[] = `listConnections -type \"constraint\"`;\nstring $shorterList[] = stringArrayRemoveDuplicates($lists);\nif(`size ($shorterList)`!=0){\nselect $shorterList;\n//pickWalk -d up;\n}}print \"zhao con wei\";\n}\n//-//-//-//-//-//\n//-//-//-//-//-//\nglobal proc twistroll(){//splineIK work\nstring $Jo[]=`ls-sl`;\nconnectAttr -f ($Jo[0]+\".rotateX\") ($Jo[1]+\".roll\");\nconnectAttr -f ($Jo[0]+\".rotateZ\") ($Jo[1]+\".twist\");\n//Krx;Krz;\nLtx;Lty;Ltz;Lry;Lsx;Lsy;Lsz;Lvis;CurveOperation threekeyadd;\n}\n//-//-//-//-//-//\n//-//-//-//-//-//\nglobal proc duochongaddcon3(){//Xyz..>X..(offset)yz..>con \nstring $selectrig[]=`ls -sl`;\nint $Josize =`size($selectrig)`;\nfor ($x = 1;$x < $Josize; $x++){\nint $tagetT = `getAttr -lock ($selectrig[$x] + \".tx\")`;\nint $tagetR = `getAttr -lock ($selectrig[$x] + \".rx\")`;\nselect $selectrig[0];GetFormLocator3;\nselect -add $selectrig[$x];\noriginnone;\nif ($tagetT==0){\nputongcon(0);\n}\nif ($tagetR==0){\nputongcon(10);\n}\n}\n}\n//-//-//-//-//-//\n//-//-//-//-//-//" 
        -optionBox 0
        -enable 1
        -visible 1
        -data 0
        -radialPosition "N" 
        -allowOptionBoxes 1
        -postMenuCommandOnce 0
        -enableCommandRepeat 1
        -echoCommand 0
        -italicized 0
        -boldFont 1
        -sourceType "mel" 
        -longDivider 1
        menuEditorMenuItem12;

    mennuu
        -label "LocalToToolW" 
        -divider 0
        -subMenu 0
        -tearOff 0
        -command "global proc AimLocalToMng(){\n\tif (`window -ex LocalToToolw`== true) deleteUI LocalToToolw;\n\twindow -t \"LocalToTool\" -sizeable 1 LocalToToolw;\n\tcolumnLayout;\n\trowLayout\t-nc 2 -cw2 70 70;\n\t\tradioCollection;\n\t\tradioButton -l \"world\" f_LtW;\n\t\tradioButton -l \"local\" f_LtL;\n\tsetParent ..;\n\trowLayout\t-nc 3 -cw3 65 65 65;\n\t\tradioCollection;\n\t\tradioButton -l \"point\" f_point;\n\t\tradioButton -l \"orient\" f_orient;\n\t\tradioButton -l \"parent\" f_parent;\n\tsetParent ..;\n\trowLayout\t-nc 2 -cw2 80 50;\n\tbutton -l \"Local_To_…\" -c LocalTo;\n\tbutton -l \"LtW_scale\" -c LtW_scale;\n\tsetParent ..;\n\tshowWindow LocalToToolw ;\n}\n///////////////////////////////////////////////////////////\nglobal proc LocalTo(){\n\tif(`radioButton -q -sl f_LtW`){\n\t\tif(`radioButton -q -sl f_point`){\n\t\t\tLtW_point;\n\t\t}else if(`radioButton -q -sl f_orient`){\n\t\t\tLtW_orient;\n\t\t}else if(`radioButton -q -sl f_parent`){\n\t\t\tLtW_parent;\n\t\t}else if(`radioButton -q -sl f_scale`){\n\t\t\tLtW_scale;\n\t\t}\n\t}\n\telse if(`radioButton -q -sl f_LtL`){\n\t\tif(`radioButton -q -sl f_point`){\n\t\t\tLtL_point;\n\t\t}else if(`radioButton -q -sl f_orient`){\n\t\t\tLtL_orient;\n\t\t}else if(`radioButton -q -sl f_parent`){\n\t\t\tLtL_parent;\n\t\t}\n\t}\n}\n////////////////////////////////////////////////////////////////\nglobal proc LtW_point(){\nglobal string $selobj[];\nglobal int $selshu;\nglobal string $mmtime;son;\n\nstring $b[];\nstring $selns;\nstring $temp;\nfor($temp in $selobj){\n\ttokenize $temp \":\" $b;\n\t\tif($b[0] != \"\"){\n\t\t\t$selns = $b[0] +\":\";\n\t\t}else{\n\t\t\t$selns = \"\";\n\t\t}\n}\n\n\tstring $PO[];\n\tstring $CO[];\n\tstring $POconstraint[];\nfor($cou=0;$cou<$selshu;$cou++){\n\t$PO[$cou] = $selobj[$cou] + \"_point01\";\n\t$CO[$cou] = $selobj[$cou] + \"_point02\";\n\t$POconstraint[$cou] = \"__constraint_\"+$cou;\n\n\tspaceLocator -n $PO[$cou];addgroupO;HideSelectedObjects;\n\tspaceLocator -n $CO[$cou];addgroupX;HideSelectedObjects;\n\tparent $CO[$cou] $PO[$cou];\n\tpointConstraint -n \"__dmy__constarint1\" $selobj[$cou] $PO[$cou];\n\tdelete \"__dmy__constarint1\";\n\tselect -r $PO[$cou];\n\tmakeIdentity -apply true -t 1 -r 1 -s 1 -n 0;\n\tpointConstraint -n $POconstraint[$cou] $selobj[$cou] $PO[$cou];\n\tselect $PO[$cou] $CO[$cou];\n\tLrx;Lry;Lrz;Lsx;Lsy;Lsz;Lvis;\n\tselect -cl;\n}\nkakusiONs;\n\tbakeResults -t $mmtime -pok true -simulation true $PO;\nkakusiOFFs;\n\tdelete $POconstraint;\nfor($cou=0;$cou<$selshu;$cou++){\n\tpointConstraint $CO[$cou] $selobj[$cou];\n}\n}\n///////////////////////////////////////////////\nglobal proc LtW_orient(){\nglobal string $selobj[];\nglobal int $selshu;\nglobal string $mmtime;son;\n\nstring $b[];\nstring $selns;\nstring $temp;\nfor($temp in $selobj){\n\ttokenize $temp \":\" $b;\n\t\tif($b[0] != \"\"){\n\t\t\t$selns = $b[0] +\":\";\n\t\t}\n\t\telse{\n\t\t\t$selns = \"\";\n\t\t}\n}\n\n\tstring $PO[];\n\tstring $CO[];\n\tstring $POconstraint[];\nfor($cou=0;$cou<$selshu;$cou++){\n\t$PO[$cou] = $selobj[$cou] + \"_orient01\";\n\t$CO[$cou] = $selobj[$cou] + \"_orient02\";\n\t$POconstraint[$cou] = \"__constraint_\"+$cou;\n\t\n\tspaceLocator -n $PO[$cou];addgroupO;HideSelectedObjects;\n\tspaceLocator -n $CO[$cou];addgroupX;HideSelectedObjects;\n\tparent $CO[$cou] $PO[$cou];\n\tpointConstraint -n \"__dmy__constarint1\" $selobj[$cou] $PO[$cou];\n\torientConstraint -n \"__dmy__constarint2\" $selobj[$cou] $PO[$cou];\n\tdelete \"__dmy__constarint1\" \"__dmy__constarint2\";\n\tselect -r $PO[$cou];\n\tmakeIdentity -apply true -t 1 -r 1 -s 1 -n 0;\n\tpointConstraint $selobj[$cou] $PO[$cou];\n\torientConstraint -n $POconstraint[$cou] $selobj[$cou] $PO[$cou];\n\tselect $PO[$cou] $CO[$cou];\n\tLtx;Lty;Ltz;Lsx;Lsy;Lsz;Lvis;\n\tselect -cl;\n}\nkakusiONs;\n\tbakeResults -t $mmtime -pok true -simulation true $PO;\nkakusiOFFs;\n\tdelete $POconstraint;\nfor($cou = 0 ; $cou < size($selobj) ; $cou++){\n\torientConstraint $CO[$cou] $selobj[$cou];\n}\n}\n////////////////////////////\nglobal proc LtW_parent(){\nglobal string $selobj[];\nglobal int $selshu;\nglobal string $mmtime;son;\n\nstring $b[];\nstring $selns;\nstring $temp;\nfor($temp in $selobj){\n\ttokenize $temp \":\" $b;\n\t\tif($b[0] != \"\"){\n\t\t\t$selns = $b[0] +\":\";\n\t\t}\n\t\telse{\n\t\t\t$selns = \"\";\n\t\t}\n}\n\n\tstring $PO[];\n\tstring $CO[];\n\tstring $POconstraint[];\nfor($cou=0;$cou<$selshu;$cou++){\n\t$PO[$cou] = $selobj[$cou] + \"_parent01\";\n\t$CO[$cou] = $selobj[$cou] + \"_parent02\";\n\t$POconstraint[$cou] = \"__constraint_\"+$cou;\n\n\tspaceLocator -n $PO[$cou];addgroupO;HideSelectedObjects;\n\tspaceLocator -n $CO[$cou];addgroupX;HideSelectedObjects;\n\tparent $CO[$cou] $PO[$cou];\n\tparentConstraint -n \"__dmy__constarint1\" $selobj[$cou] $PO[$cou];\n\tdelete \"__dmy__constarint1\";\n\tselect -r $PO[$cou];\n\tmakeIdentity -apply true -t 1 -r 1 -s 1 -n 0;\n\tparentConstraint -n $POconstraint[$cou] $selobj[$cou] $PO[$cou];\n\tselect $PO[$cou] $CO[$cou];\n\tLsx;Lsy;Lsz;Lvis;\n\tselect -cl;\n}\nkakusiONs;\n\tbakeResults -t $mmtime -pok true -simulation true $PO;\nkakusiOFFs;\n\tdelete $POconstraint;\nfor($cou=0;$cou <$selshu;$cou++){\n\tparentConstraint $CO[$cou] $selobj[$cou];\n}\n}\n//////////////////////////////////////\nglobal proc LtW_scale(){\nglobal string $selobj[];\nglobal int $selshu;\nglobal string $mmtime;son;\n\nstring $b[];\nstring $selns;\nstring $temp;\nfor($temp in $selobj){\n\ttokenize $temp \":\" $b;\n\t\tif($b[0] != \"\"){\n\t\t\t$selns = $b[0] +\":\";\n\t\t}\n\t\telse{\n\t\t\t$selns = \"\";\n\t\t}\n}\n\n\tstring $PO[];\n\tstring $CO[];\n\tstring $POconstraint[];\nfor($cou=0;$cou<$selshu;$cou++){\n\t$PO[$cou] = $selobj[$cou] + \"_point01\";\n\t$CO[$cou] = $selobj[$cou] + \"_point02\";\n\t$POconstraint[$cou] = \"__constraint_\"+$cou;\n\n\tspaceLocator -n $PO[$cou];addgroupO;HideSelectedObjects;\n\tspaceLocator -n $CO[$cou];addgroupX;HideSelectedObjects;\n\tparent $CO[$cou] $PO[$cou];\n\tscaleConstraint -n \"__dmy__constarint1\" $selobj[$cou] $PO[$cou];\n\tdelete \"__dmy__constarint1\";\n\tselect -r $PO[$cou];\n\tmakeIdentity -apply true -t 1 -r 1 -s 1 -n 0;\n\tscaleConstraint -n $POconstraint[$cou] $selobj[$cou] $PO[$cou];\n\tselect $PO[$cou] $CO[$cou];\n\tLtx;Lty;Ltz;Lrx;Lry;Lrz;Lvis;\n\tselect -cl;\n}\nkakusiONs;\n\tbakeResults -t $mmtime -pok true -simulation true $PO;\nkakusiOFFs;\n\tdelete $POconstraint;\nfor($cou=0;$cou<$selshu;$cou++){\n\tscaleConstraint $CO[$cou] $selobj[$cou];\n}\n}\n//////////////////////////////////////\nglobal proc LtL_point(){\nglobal string $selobj[];\nglobal int $selshu;\nglobal string $mmtime;son;\n\nstring $b[];\nstring $selns;\nstring $temp;\nfor($temp in $selobj){\n\ttokenize $temp \":\" $b;\n\t\tif($b[0] != \"\"){\n\t\t\t$selns = $b[0] +\":\";\n\t\t}\n\t\telse{\n\t\t\t$selns = \"\";\n\t\t}\n}\n\tstring $CO[];\n\tstring $PO[];\n\tstring $chO[];\n\tstring $POconstraint[];\n\tstring $PA = ($selobj[0] +\"_parent\");\n\tif(`objExists $PA`==0){\n\t\tspaceLocator -n $PA;addgroupO;HideSelectedObjects;\n\t}\n\tint $cou;\n\tfor($cou=1;$cou<$selshu;$cou=$cou+1){\n\t\tstring $COloc = ($selobj[$cou] +\"_Lpoint01\");\n\t\tstring $POloc = ($selobj[$cou] +\"_Lpoint02\");\n\t\tstring $chloc = ($selobj[$cou] +\"_Lpoint03\");\n\t\tspaceLocator -n $COloc;HideSelectedObjects;\n\t\t\tparentConstraint -n \"_cons1\" ($selobj[0] +\"_parent\") $COloc;\n\t\tspaceLocator -n $POloc;HideSelectedObjects;\n\t\tspaceLocator -n $chloc;addgroupX;HideSelectedObjects;\n\t\tparent $chloc $POloc;\n\t\t\tpointConstraint -n (\"_cons_\"+$cou) $selobj[$cou] $POloc;\n\t\tparent $POloc $COloc;\n\t\tparent $COloc $PA;\n\t\tdelete \"_cons1\";\n\t\t$CO[$cou-1] = $COloc;\n\t\t$PO[$cou-1] = $POloc;\n\t\t$chO[$cou-1] = $chloc;\n\t\t$POconstraint[$cou-1] = (\"_cons_\"+$cou);\n\t\tselect $COloc $POloc $chloc;Lrx;Lry;Lrz;Lsx;Lsy;Lsz;Lvis;\n\t}\n\tparentConstraint $selobj[0] $PA;\n\t    select $PA;allLo;\nkakusiONs;\n\tbakeResults -t $mmtime -pok true -simulation true $PO;\nkakusiOFFs;\n\tfor($n=0;$n<size($PO);$n++){\n\t\tdelete $POconstraint[$n];\n\t\tpointConstraint $chO[$n] $selobj[$n+1];\n\t}\n}\n\n//////////////////////////////////////////////////\nglobal proc LtL_orient(){\nglobal string $selobj[];\nglobal int $selshu;\nglobal string $mmtime;son;\n\nstring $b[];\nstring $selns;\nstring $temp;\nfor($temp in $selobj){\n\ttokenize $temp \":\" $b;\n\t\tif($b[0] != \"\"){\n\t\t\t$selns = $b[0] +\":\";\n\t\t}\n\t\telse{\n\t\t\t$selns = \"\";\n\t\t}\n}\n\tstring $CO[];\n\tstring $PO[];\n\tstring $chO[];\n\tstring $POconstrainta[];\n\tstring $POconstraintb[];\n\tstring $PA = ($selobj[0] +\"_parent\");\n\tif(`objExists $PA`==0){\n\t\tspaceLocator -n $PA;addgroupO;HideSelectedObjects;\n\t}\n\tint $cou;\n\tfor($cou=1;$cou<$selshu;$cou=$cou+1){\n\t\tstring $COloc = ($selobj[$cou] +\"_Lorient01\");\n\t\tstring $POloc = ($selobj[$cou] +\"_Lorient02\");\n\t\tstring $chloc = ($selobj[$cou] +\"_Lorient03\");\n\t\tspaceLocator -n $COloc;HideSelectedObjects;\n\t\t\tparentConstraint -n \"_cons1\" ($selobj[0] +\"_parent\") $COloc;\n\t\tspaceLocator -n $POloc;HideSelectedObjects;\n\t\tspaceLocator -n $chloc;addgroupX;HideSelectedObjects;\n\t\tparent $chloc $POloc;\n\t\t\tpointConstraint -n (\"_cons_a_\"+$cou) $selobj[$cou] $POloc;\n\t\t\torientConstraint -n (\"_cons_b_\"+$cou) $selobj[$cou] $POloc;\n\t\tparent $POloc $COloc;\n\t\tparent $COloc $PA;\n\t\tdelete \"_cons1\";\n\t\t$CO[$cou-1] = $COloc;\n\t\t$PO[$cou-1] = $POloc;\n\t\t$chO[$cou-1] = $chloc;\n\t\t$POconstrainta[$cou-1] = (\"_cons_a_\"+$cou);\n\t\t$POconstraintb[$cou-1] = (\"_cons_b_\"+$cou);\n\t\tselect $COloc $POloc $chloc;\n\t\tLtx;Lty;Ltz;Lsx;Lsy;Lsz;Lvis;\n\t}\n\tparentConstraint $selobj[0] $PA;\n\t\tselect $PA;allLo;;\nkakusiONs;\n\tbakeResults -t $mmtime -pok true -simulation true $PO;\nkakusiOFFs;\n\tfor($n=0;$n<size($PO);$n++){\n\t\tdelete $POconstrainta[$n] $POconstraintb[$n];\n\t\torientConstraint $chO[$n] $selobj[$n+1];\n\t}\n}\n\n\n//////////////////////////////////////////////////\nglobal proc LtL_parent(){\nglobal string $selobj[];\nglobal int $selshu;\nglobal string $mmtime;son;\n\nstring $b[];\nstring $selns;\nstring $temp;\nfor($temp in $selobj){\n\ttokenize $temp \":\" $b;\n\t\tif($b[0] != \"\"){\n\t\t\t$selns = $b[0] +\":\";\n\t\t}\n\t\telse{\n\t\t\t$selns = \"\";\n\t\t}\n}\n\n\tstring $CO[];\n\tstring $PO[];\n\tstring $chO[];\n\tstring $POconstraint[];\n\tstring $PA = ($selobj[0] +\"_parent\");\n\tif(`objExists $PA`==0){\n\t\tspaceLocator -n $PA;addgroupO;HideSelectedObjects;\n\t}\n\tint $cou;\n\tfor($cou=1;$cou<$selshu;$cou=$cou+1){\n\t\tstring $COloc = ($selobj[$cou] +\"_Lparent01\");\n\t\tstring $POloc = ($selobj[$cou] +\"_Lparent02\");\n\t\tstring $chloc = ($selobj[$cou] +\"_Lparent03\");\n\t\tspaceLocator -n $COloc;HideSelectedObjects;\n\t\t\tparentConstraint -n \"_cons1\" ($selobj[0] +\"_parent\") $COloc;\n\t\tspaceLocator -n $POloc;HideSelectedObjects;\n\t\tspaceLocator -n $chloc;addgroupX;HideSelectedObjects;\n\t\tparent $chloc $POloc;\n\t\t\tparentConstraint -n (\"_cons_\"+$cou) $selobj[$cou] $POloc;\n\t\tparent $POloc $COloc;\n\t\tparent $COloc $PA;\n\t\tdelete \"_cons1\";\n\t\t$CO[$cou-1] = $COloc;\n\t\t$PO[$cou-1] = $POloc;\n\t\t$chO[$cou-1] = $chloc;\n\t\t$POconstraint[$cou-1] = (\"_cons_\"+$cou);\n\t\tselect $COloc $POloc $chloc;\n\t\tLsx;Lsy;Lsz;Lvis;\n\t}\n\tparentConstraint $selobj[0] $PA;\n\t\tselect $PA;allLo;\nkakusiONs;\n\tbakeResults -t $mmtime -pok true -simulation true $PO;\nkakusiOFFs;\n\tfor($n=0;$n<size($PO);$n++){\n\t\tdelete $POconstraint[$n];\n\t\tparentConstraint $chO[$n] $selobj[$n+1];\n\t}\n}\n//////////////////////////////\nglobal proc addgroupO(){\nstring $lotoya[]=`ls-sl`;\nCreateEmptyGroup;\nrename \"bayunpaiO\";\nselect -tgl $lotoya;\nparent;\npickWalk -d up;\noutlinecolor(110);\n}\n//\nglobal proc addgroupX(){\nstring $lotoya[]=`ls-sl`;\nCreateEmptyGroup;\nrename \"bayunpaiX\";\nselect -tgl $lotoya;\nparent;\npickWalk -d up;\noutlinecolor(110);\n}\n//////////////////////////////\nglobal proc LtWLauto(string $wl){\nif($wl==\"W\"){\nTObianbieTO;\nif(`objExists RRRR`){//////\nselect -ne RRRR;\npickWalkRight;\nLtW_orient;\ndelete RRRR;\n}\nif(`objExists TTTT`){\nselect -ne TTTT;\npickWalkRight;\nLtW_point;\ndelete TTTT;\n}\nif(`objExists TTRR`){\nselect -ne TTRR;\npickWalkRight;\nLtW_parent;\ndelete TTRR;\n}\nif(`objExists noTTRR`){\ndelete noTTRR;\n}\n}else if($wl==\"L\"){//////\nstring $sel[]=`ls-sl`;\nzhugejianxuan;\nTObianbieTO;\nif(`objExists RRRR`){\nselect -ne RRRR;\npickWalkRight;\nstring $selko[]=`ls-sl`;\nselect $sel[0] $selko;\nLtL_orient;\ndelete RRRR;\n}\nif(`objExists TTTT`){\nselect -ne TTTT;\npickWalkRight;\nstring $selko[]=`ls-sl`;\nselect $sel[0] $selko;\nLtL_point;\ndelete TTTT;\n}\nif(`objExists TTRR`){\nselect -ne TTRR;\npickWalkRight;\nstring $selko[]=`ls-sl`;\nselect $sel[0] $selko;\nLtL_parent;\ndelete TTRR;\n}\nif(`objExists noTTRR`){\ndelete noTTRR;\n}\n\n}\nselect -cl;\nprint \"LtWLauto.............\";\n}//LtWLauto(\"W\");" 
        -optionBox 0
        -enable 1
        -visible 1
        -data 0
        -radialPosition "NE" 
        -allowOptionBoxes 1
        -postMenuCommandOnce 0
        -enableCommandRepeat 1
        -echoCommand 0
        -italicized 0
        -boldFont 1
        -sourceType "mel" 
        -longDivider 1
        menuEditorMenuItem13;

    mennuu
        -label "CutTimeW      >newCuttime" 
        -divider 0
        -subMenu 0
        -tearOff 0
        -command "global proc Cuttime(){\nif (`window -ex cuttimew`) deleteUI cuttimew;//else Cuttime;\nwindow -title \"frame\" -s 1 cuttimew ;\ncolumnLayout;\nrowLayout -nc 4;\nbutton -l \"A\" -w 40  -h 15 -c CutTime_A cuttimeA ;\nbutton -l \"B\" -w 40  -h 15 -c CutTime_B cuttimeB ;  \nbutton -l \"C\" -w 40  -h 15 -c CutTime_C cuttimeC ;\nbutton -l \"D\" -w 40  -h 15 -c CutTime_D cuttimeD ;  \nsetParent ..;\nshowWindow ;\nwindow -e -h 20 -w 100 cuttimew;\n}Cuttime;\n//\nglobal proc CutTime_abcd(string $cmd){\nglobal float $time_a;\nglobal float $time_b;\nglobal float $time_c;\nglobal float $time_d;\n$currentTime = `currentTime -query`;\n\tif ($cmd == \"CutTime_A\" || $cmd == \"CutTime_B\" || $cmd == \"CutTime_C\" || $cmd == \"CutTime_D\"){\n\t\tswitch ($cmd) {\n\t\t\tcase \"CutTime_A\":\n\t\t\t\t$time_a = `currentTime -query`;\n\t\t\t\tbutton -e -label (\"f \" + $time_a) cuttimeA;\n\t\t\tbreak;\n\t\t\tcase \"CutTime_B\":\n\t\t\t\t$time_b = `currentTime -query`;\n\t\t\t\tbutton -e -label (\"f \" + $time_b) cuttimeB;\n\t\t\tbreak;\n\t\t\tcase \"CutTime_C\":\n\t\t\t\t$time_c = `currentTime -query`;\n\t\t\t\tbutton -e -label (\"f \" + $time_c) cuttimeC;\n\t\t\tbreak;\n\t\t\tcase \"CutTime_D\":\n\t\t\t\t$time_d = `currentTime -query`;\n\t\t\t\tbutton -e -label (\"f \" + $time_d) cuttimeD;\n\t\t\tbreak;\n\t\t}\n\t}else if ($cmd == \"select_1_2\" || $cmd == \"select_2_3\" || $cmd == \"select_1_3\" || $cmd == \"select_4\"){\n\t\tswitch ($cmd) {\n\t\t\tcase \"select_1_2\":\n\t\t\t\tif ($currentTime == $time_a){\n\t\t\t\t\tcurrentTime $time_b;\n\t\t\t\t}else{\n\t\t\t\t\tcurrentTime $time_a;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"select_2_3\":\n\t\t\t\tif ($currentTime == $time_b){\n\t\t\t\t\tcurrentTime $time_c;\n\t\t\t\t}else{\n\t\t\t\t\tcurrentTime $time_b;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"select_1_3\":\n\t\t\t\tif ($currentTime == $time_c){\n\t\t\t\t\tcurrentTime $time_a;\n\t\t\t\t}else{\n\t\t\t\t\tcurrentTime $time_c;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\tcase \"select_4\":\n\t\t\t\t//if ($currentTime == $time_d){\n\t\t\t\t\tcurrentTime $time_d;\n\t\t\tbreak;\n\t\t}\n\t}\n}" 
        -optionBox 0
        -enable 1
        -visible 1
        -data 0
        -radialPosition "E" 
        -allowOptionBoxes 1
        -postMenuCommandOnce 0
        -enableCommandRepeat 1
        -echoCommand 0
        -italicized 0
        -boldFont 1
        -sourceType "mel" 
        -longDivider 1
        menuEditorMenuItem14;

    mennuu
        -label "ChangeSelectionMask" 
        -divider 0
        -subMenu 1
        -tearOff 0
        -optionBox 0
        -enable 1
        -visible 1
        -data 0
        -allowOptionBoxes 1
        -enableCommandRepeat 1
        -italicized 0
        -boldFont 1
        -sourceType "mel" 
        -longDivider 1
        menuEditorMenuItem10;

        mennuu
            -label "addnewrig_window" 
            -divider 0
            -subMenu 0
            -tearOff 0
            -command "global proc addnewrig_window(){\nif(`window -ex addsprig` == true )deleteUI addsprig;\nwindow -sizeable 1 -mnb false -mxb false -title \"addsprig\" addsprig;\ncolumnLayout;\nrowLayout -nc 10 -cw2 5 10;\nbutton -w 30 -l \" 1 \" -c \"addnewrig2a\" -ann \"rigxxxx sele go/no $A$B\";\n//global string $kazuInputField[1];\n//$kazuInputField[1]=`textField -w 15`;\nbutton -w 10 -label \"> \" -ann \"xu shou dong beizhucon\" ;\nintField -w 20 -minValue -1 -maxValue 12 -value 0 -cc Gooo newV ;\nbutton -w 30 -l \" 2 \" -c \"addnewrig2b\" ;\nbutton -w 30 -l \"new1\" -c \"addnewrig2a_pingjun\";\nbutton -w 33 -l \"reset\" -c addnewrig_window;\nsetParent ..;\n\nrowLayout -nc 10 -cw2 5 10;\nbutton -w 30 -l \"0\" -c \"oyasele\";\nbutton -w 30 -l \"1 \" -c \"kosele\";\nbutton -w 10 -l \"> \" -c \"\";\nbutton -w 30 -l \"go\" -c \"addnewrig_autoXP(99)\";\nbutton -w 25 -l \"3p\" -c \"addnewrig_autoXP(3)\";\nbutton -w 25 -l \"4p\" -c \"addnewrig_autoXP(4)\";\nbutton -w 25 -l \"5p\" -c \"addnewrig_autoXP(5)\";\nsetParent ..;\n\nrowLayout -nc 11 -cw2 5 20;\nbutton -w 30 -l \"lianA\" -c \"BuildBoneChain_aimConstraint\" -ann \"abcd...rigsele>joint(aim)\";\nbutton -w 30 -l \"<x2\" -c \"Wbonchain_aim\";\nbutton -w 30 -l \"lianB\" -c \"BuildBoneChain_poConstraint\" -ann \"abcd...rigsele>joint(poCon)\";\nseparator -hr 0 -h 15 ;\nbutton -w 50 -l \"Pcon\" -c \"lianconrig_p\" -ann \"rig...+lian...>fancong(LtL_point)\";\nsetParent ..;\n\nrowLayout -nc 11 -cw2 5 20;\nbutton -w 40 -l \"C_lian\" -c \"springsetA(1)\"  -ann \"abcd...rigsele>newjoint(yunchen).springsetA(1)\";\nbutton -w 30 -l \"Cx2\" -c \"springsetA(2)\"  -ann \"joint shuliang x2(nocon).springsetA(2)\";\nbutton -w 40 -l \"handO\" -c \"springsetB\"  -ann \"rig+lot.springsetB\";\nbutton -w 40 -l \"I_lian\" -c \"springsetC(1)\"  -ann \"abcd...rigsele>newjoint(bizhi+yunchen).springsetC(1)\";\nbutton -w 30 -l \"Ix2\" -c \"springsetC(2)\"  -ann \"joint shuliang x2.springsetC(2)\";\nsetParent ..;\n\nshowWindow addsprig;\n}//addnewrig_window;\n//1   造錬\n//2  // set Oya Ko>addnewrig_autoXP(99);\n//3  //反con//骨錬下”_GG”+rig...>LtL_orient\n/////////////////////////////////////////////////////////\nglobal proc oyasele(){\nglobal string $skirt0[];\n//string\t$skirt0[]=`ls-sl`;\n$skirt0=`ls-sl`;\n\tprint $skirt0;\n}\n//\nglobal proc kosele(){\nglobal string $skirt1[];\n//string\t$skirt1[]=`ls-sl`;\n$skirt1=`ls-sl`;\n\tprint $skirt1;\n}\n/////////////////////////////////////////////////////////\n/////////////////////////////////////////////////////////\nglobal proc addnewrig2a(){\nglobal string $motoall[];\nglobal string $gu_offset[];\n//\n//string $motoall[]=`ls -sl`;\n$motoall=`ls -sl`;\n$createSetResult = `sets -name \"start\"`;\nGetFormLocator2;\nstring $LotallA[] = `ls-sl`;\nint $Lotallaa =`size($LotallA)`;\nint $x;\nfor ($x = 0;$x < $Lotallaa; $x++){\nselect $LotallA[$x]; \nsetAttr ($LotallA[$x] + \".rx\") 0;\nsetAttr ($LotallA[$x] + \".ry\") 0;\nsetAttr ($LotallA[$x] + \".rz\") 0;\njoint ;\nrename ($motoall[0]+$x);\nGetFormGroup2;\nrename ($motoall[0]+$x+\"_GG\");\nstring $Gconko[] = `ls-sl`;\n$GGo[$x] = $Gconko[0]; \nselect $GGo;\n}//string $gu_offset[]=`ls -sl`;\n$gu_offset=`ls -sl`;\n//\nselect $LotallA;pickWalk -d down;pickWalk -d right;\nstring $selectObj[0] = `ls -sl`;\nmakeIdentity -apply true -t 0 -r 0 -s 1 -n 0;\nfor($ma=1; $ma < (size($selectObj)+1); $ma++){ \nif ($ma < size($selectObj)){ \nparent $selectObj[$ma] $selectObj[$ma-1] ;\n}}\nstring $J_last[] = `ls -sl`;\n//\nfor($sObj=0; $sObj < size($selectObj); $sObj++){ \nif ($sObj < size($selectObj)){\nselect -add $selectObj[$sObj];\n}}\nstring $gulian[]=`ls-sl`;\nparent -w $gulian[0];\ndelete $LotallA;\nselect $gulian[0] $J_last[0];\n}//addnewrig2a\n/////////////////////////////////////////////////////////\nglobal proc Gooo(){\nglobal string $motoall[];\n//\nint $kazu=`intField -q -value newV`;\nif($kazu<=3){print \"4+\";\n}else{\nint $Cvsize=$kazu-3;//-ns*\nint $Cvsizeb=$kazu-1;\n    string $Jo[] = `ls-sl`;\n    ikHandle -n \"_handleXiaoJie\" -sol ikSplineSolver -roc false -pcv false -ns $Cvsize;\n    select curve1;rename \"curveXiaoJie\";\n//\nint $x;\nfor ($x = 0;$x < $kazu; $x++){\ncluster (\"curveXiaoJie\" + \".cv[\" + $x + \"]\"); \nrename (\"xiaojie_\"+$x+\"_cluster\");\n}\nCreateEmptyGroup;rename \"rolltwist\";\nselect -tgl \"_handleXiaoJie\" ;\ntwistroll;\n//\nselect \"xiaojie_*_cluster\";\nstring $clusters[]=`ls-sl`;\nselect $motoall[0] $clusters[0];AIPcon;\nselect $motoall;danxuanlast;\nselect -tgl $clusters[$Cvsizeb];AIPcon;\nselect $motoall[0] $Jo[0];AIPcon;\nprint \"clusters NO set!!!!!!!!!!rig+cluster+duochongaddcon1>go\";\n}\n}//Gooo;\n/////////////////////////////////////////////////////////\nglobal proc addnewrig2b(){\nglobal string $motoall[];\nglobal string $gu_offset[];\n//\nselect \"xiaojie_*_cluster\";\nstring $clusterall[]=`ls-sl`;\nselect $clusterall;select -d $clusterall[0] $clusterall[`size ($clusterall)`-1] ;\nfoundconsaki;PickWalkUp;\nstring $sss[]=`ls-sl`;\nselect $clusterall;select -d $clusterall[0];\nsonbakeT;\nfoundconmubiao;select -add $sss;delete;\nselect $motoall[0] $clusterall;select -d $clusterall[0];\nLtW_point;\n////\nselect $motoall;select -d $motoall[0];\nQA_pickOrigin;\nselect $gu_offset;select -d $gu_offset[0];\nQA_pickTarget;\nQAapllycon(0,1);\nsonbakeO;\nfoundconmubiao;delete;\nQAapllycon(1,1);\n//\nselect $motoall[0] $clusterall;select -d $clusterall[0];\nfoundconsaki;PickWalkUp;select -add rolltwist;group;\n\nselect $gu_offset[0];PickWalkUp;\nselect -add _handleXiaoJie curveXiaoJie \"xiaojie_*_cluster\";\ngaimingzi(\"shoudong_\");\ngroup;HideSelectedObjects;\n}//addnewrig2b\n/////////////////////////////////////////////////////////\nglobal proc addnewrig2a_pingjun(){\naddnewrig2a;\nstring $selwj[]=`ls-sl`;\nikHandle -sol ikSplineSolver -ns 4 -n lishen;\ndelete lishen;\nselect $selwj[0];\nSelectHierarchy;\nint $selejshu = size( `ls -sl -type joint` );\nrename curve1 sscurve;\njointoncurve($selejshu,\"sscurve\");\nselect $selwj[0];PickWalkUp;\nselect -tgl piaopiaogu1;//sunxujiaohuan;parent;\nselect -r \"piaopiaogu*\";\nstring $newj[]=`ls-sl`;\nselect -r \"*_GG\" ;\nstring $offsetg[]=`ls-sl`;\nfor($i = 0; $i <(`size($newj)`);$i++){\nparent $offsetg[$i] $newj[$i];\n}\ndelete $selwj[0] sscurve;\nselect $newj[0] $newj[$i-1];\n}//addnewrig2a_pingjun" 
            -optionBox 0
            -enable 1
            -visible 1
            -data 0
            -allowOptionBoxes 1
            -postMenuCommandOnce 0
            -enableCommandRepeat 1
            -echoCommand 0
            -italicized 0
            -boldFont 1
            -sourceType "mel" 
            -longDivider 1
            menuEditorMenuItem10;

        mennuu
            -label "addnewrig_auto" 
            -divider 0
            -subMenu 0
            -tearOff 0
            -command "global proc addnewrig_autoXP(int $sansi){\n//https://www.youtube.com/watch?v=B_-8i9qPUBw\nglobal string $skirt0[];\nglobal string $skirt1[];  \nselect $skirt0 $skirt1;\nstring $motoall[]=`ls -sl`;\n$createSetResult = `sets -name \"start\"`;\ndanxuanlast;\nstring $motolast[]=`ls-sl`;\n//\nselect $skirt1;\nGetFormLocator2;\nstring $LotallA[] = `ls-sl`;\nint $Lotallaa =`size($LotallA)`;\nint $x;\n$y = 1;\nfor ($x = 0;$x < $Lotallaa; $x++){\nselect $LotallA[$x]; \nsetAttr ($LotallA[$x] + \".rx\") 0;\nsetAttr ($LotallA[$x] + \".ry\") 0;\nsetAttr ($LotallA[$x] + \".rz\") 0;\njoint ;\nstring $namae =  $motoall[1] + $x;rename $namae ;\nGetFormGroup2;\nstring $namae2 = $motoall[1] + $x+\"_GG\";rename  $namae2 ;\nstring $Gconko[] = `ls-sl`;\n$GGo[$x] = $Gconko[0]; \n$y++;\nselect $GGo;\n}\npickWalk -d up;\n//\nstring $selectObj[0]=`ls-sl`;\nmakeIdentity -apply true -t 0 -r 0 -s 1 -n 0;\nfor($ma=1; $ma < (size($selectObj)+1); $ma++){ \nif ($ma < size($selectObj)){ \nparent $selectObj[$ma] $selectObj[$ma-1] ;\n}}\n//\nstring $J_last[] = `ls -sl`;\nfor($sObj=0; $sObj < size($selectObj); $sObj++){ \nif ($sObj < size($selectObj)){    \nselect -add $selectObj[$sObj];              \n}}\n//\nparent -w $selectObj[0];\ndelete $LotallA;\nselect -r $selectObj;pickWalk -d down;\nstring $GGo2[]=`ls-sl`;\nselect -r $selectObj[0];select -tgl $J_last;\n////////////////////\n////////////////////\n////////////5rig\nglobal string $ss[];\nif($sansi==5){\nikHandle -n \"_handleXiaoJie\" -sol ikSplineSolver -roc false -pcv false -ns 4;\nrename curve1 curveXiaoJie;\ncluster -n \"xiaojie0cluster\" (\"curveXiaoJie\" + \".cv[0:1]\");\ncluster -n \"xiaojie1cluster\" (\"curveXiaoJie\" + \".cv[2]\");\ncluster -n \"xiaojie2cluster\" (\"curveXiaoJie\" + \".cv[3]\");\ncluster -n \"xiaojie3cluster\" (\"curveXiaoJie\" + \".cv[4]\");\ncluster -n \"xiaojie4cluster\" (\"curveXiaoJie\" + \".cv[5:6]\");\nselect -r \"xiaojie*clusterHandle\" ;\n//\nCreateEmptyGroup;rename \"rolltwist\";\nselect -tgl \"_handleXiaoJie\" ;\ntwistroll;\n////\nselect $skirt0 xiaojie0clusterHandle;AIPcon;\nselect $skirt1;danxuanlast; select -add xiaojie4clusterHandle;\nduochongaddcon2;\nselect $skirt0 $selectObj[0];AIPcon;\nselect $skirt1[`size ($skirt1)`/2/2] $skirt1[`size ($skirt1)`/2] $skirt1[`size ($skirt1)`/2+`size ($skirt1)`/2/2];\naddlotbake;\nstring $ss[]=`ls-sl`;\nselect $ss[0] xiaojie1clusterHandle;\nduochongaddcon2;\nselect $ss[1] xiaojie2clusterHandle;\nduochongaddcon2;\nselect $ss[2] xiaojie3clusterHandle;\nduochongaddcon2;\nselect \"xiaojie*clusterHandle\";\nselect -d xiaojie0clusterHandle;\nsonbakeT;\nfoundconmubiao;delete;\nselect $ss;delete;\n}\n////////////////////\n////////////////////\n////////////4rig\nif($sansi==4){\nikHandle -n \"_handleXiaoJie\" -sol ikSplineSolver -roc false -pcv false -ns 3;\nrename curve1 curveXiaoJie;\ncluster -n \"xiaojie0cluster\" (\"curveXiaoJie\" + \".cv[0:1]\");\ncluster -n \"xiaojie1cluster\" (\"curveXiaoJie\" + \".cv[2]\");\ncluster -n \"xiaojie2cluster\" (\"curveXiaoJie\" + \".cv[3]\");\ncluster -n \"xiaojie3cluster\" (\"curveXiaoJie\" + \".cv[4:5]\");\nselect -r \"xiaojie*clusterHandle\" ;\n//\nCreateEmptyGroup;rename \"rolltwist\";\nselect -tgl \"_handleXiaoJie\" ;\ntwistroll;\n////\nselect $skirt0 xiaojie0clusterHandle;AIPcon;\nselect $skirt1;danxuanlast; select -add xiaojie3clusterHandle;\nduochongaddcon2;\nselect $skirt0 $selectObj[0];AIPcon;\nselect $skirt1[`size ($skirt1)`/2/2] $skirt1[`size ($skirt1)`/2+`size ($skirt1)`/2/2];\naddlotbake;\nstring $ss[]=`ls-sl`;\nselect $ss[0] xiaojie1clusterHandle;\nduochongaddcon2;\nselect $ss[1] xiaojie2clusterHandle;\nduochongaddcon2;\nselect \"xiaojie*clusterHandle\";\nselect -d xiaojie0clusterHandle;\nsonbakeT;\nfoundconmubiao;delete;\nselect $ss;delete;\n}\n////////////3rig\nelse if($sansi==3){\nikHandle -n \"_handleXiaoJie\" -sol ikSplineSolver -roc false -pcv false -ns 2;\nrename curve1 curveXiaoJie;\ncluster -n \"xiaojie0cluster\" (\"curveXiaoJie\" + \".cv[0:1]\");\ncluster -n \"xiaojie1cluster\" (\"curveXiaoJie\" + \".cv[2]\");\ncluster -n \"xiaojie2cluster\" (\"curveXiaoJie\" + \".cv[3:4]\");\nselect -r \"xiaojie*clusterHandle\" ;\n//\nCreateEmptyGroup;rename \"rolltwist\";\nselect -tgl \"_handleXiaoJie\" ;\ntwistroll;\n////\nselect $skirt0 xiaojie0clusterHandle;AIPcon;\nselect $skirt1;danxuanlast; select -add xiaojie2clusterHandle;\nduochongaddcon2;\nselect $skirt0 $selectObj[0];AIPcon;\nselect $skirt1[`size ($skirt1)`/2];\naddlotbake;\nstring $ss[]=`ls-sl`;\nselect $ss[0] xiaojie1clusterHandle;\nduochongaddcon2;\nselect \"xiaojie*clusterHandle\";\nselect -d xiaojie0clusterHandle;\nsonbakeT;\nfoundconmubiao;delete;\nselect $ss;delete;\n}\n///////\n///////\n///////\n///////\n///////\n///////\n///////\n///////\nif($sansi==9){\n$aaa=`size ($skirt1)`-1;\n$bbb=`size ($skirt1)`;\n$ccc=`size ($skirt1)`+1;\n\nikHandle -n \"_handleXiaoJie\" -sol ikSplineSolver -roc false -pcv false -ns $aaa;\nrename curve1 curveXiaoJie;\n\n\ncluster -n \"xiaojie0cluster\" (\"curveXiaoJie\" + \".cv[0:1]\");\ngaimingzi \"xj_1\";\nfor ($x = 2;$x < $bbb; $x++){\ncluster -n \"xiaojie1cluster\" (\"curveXiaoJie\" + \".cv[\" + $x + \"]\");\ngaimingzi (\"xj_\"+$x);\n}\ncluster -n \"xiaojie4cluster\" (\"curveXiaoJie\" + \".cv[\"+$bbb+\":\"+$ccc+\"]\");\ngaimingzi  (\"xj_\"+$bbb);\nselect -r \"xj_*clusterHandle\" ;\nstring $clusters[]=`ls-sl`;//clusters\n//\nCreateEmptyGroup;rename \"rolltwist\";\nselect -tgl \"_handleXiaoJie\" ;\ntwistroll;\n////\n\nselect $skirt0 $clusters[0];AIPcon;\nselect $skirt1;danxuanlast; select -add $clusters[`size ($clusters)`-1];\nduochongaddcon2;\nselect $skirt0 $selectObj[0];AIPcon;\nselect $skirt1;\nselect -d $skirt1[0];select -d $skirt1[`size ($skirt1)`-1];\naddlotbake;\nstring $ss[]=`ls-sl`;//Lot\n\nfor ($x = 0;$x < `size ($skirt1)`-2; $x++){\nselect $ss[$x] $clusters[$x+1];\nduochongaddcon2;\n}\nselect $clusters;\nselect -d $clusters[0];\nsonbakeT;\nfoundconmubiao;delete;\nselect $ss;delete;\n//////////////////////////////////\nselect $skirt0 $clusters;\nselect -d $clusters[0];\nstring $conzhi[]=`ls-sl`;\nLtW_point;\n//\nselect $GGo2;\nQA_pickTarget;\nselect $skirt1;\nQA_pickOrigin;\nQAapllycon(0,1);\nselect $GGo2;\nsonbakeO;\nselect $GGo2;pickWalk -d down;delete;\nQAapllycon(1,1);\n//\nselect $conzhi;foundconsaki;pickWalk -d up;\nselect -add rolltwist;group;outlinecolor(000);\nselect $selectObj[0] _handleXiaoJie curveXiaoJie $clusters;\ngroup;outlinecolor(000);\nstring $mingziall[]=`ls-sl`;HideSelectedObjects;\nselect $mingziall rolltwist $selectObj[0] _handleXiaoJie curveXiaoJie $clusters;\ngaimingzi(\"X_\");\n}\n//////////////////////////////////\n///////\n///////\n///////\n///////\n///////99rig\n///////99rig\nif($sansi==99){\nint $rigshuliang =`size($skirt1)`;\ncurve -n \"curveXiaoJie\" -d 3 -p 0 0 0 -p 0 0 1 -p 0 0 2 -p 0 0 3 -k 0 -k 0 -k 0 -k 1 -k 1 -k 1 ;\nint $x;int $y;\nfor ($x = 3;$x < $rigshuliang-1; $x++){\nselect -r curveXiaoJie.cv[$x];\ncurve -os -a -p 0 0 $x curveXiaoJie;\n}\nfor ($y = 0;$y < $rigshuliang; $y++){\nselect -r curveXiaoJie.cv[$y];\nnewCluster \" -envelope 1\";\nrename (\"xiaojie\"+$y+\"clusterHandle\");\nstring $clusterH[] = `ls-sl`;\npointConstraint $skirt1[$y] $clusterH;\n}\nselect \"xiaojie*clusterHandle\" ;\nsonbakeT;foundconmubiao;delete;\nselect $skirt0 xiaojie0clusterHandle;AIPcon;\nselect $skirt0 $selectObj[0];AIPcon;\nselect -r $selectObj[0] $J_last curveXiaoJie;\nikHandle -sol ikSplineSolver -ccv false -roc false -pcv false curveXiaoJie;\nrename \"_handleXiaoJie\";\nCreateEmptyGroup;rename \"rolltwist\";\nselect -tgl \"_handleXiaoJie\" ;\ntwistroll;\n}\n////////////////////\n////////////////////\n////////////////////\n////////////////////\n////////////////////\n////////////8rig   \nglobal string $ss[];\nif($sansi==888){\nikHandle -n \"_handleXiaoJie\" -sol ikSplineSolver -roc false -pcv false -ns 7;\nrename curve1 curveXiaoJie;\ncluster -n \"xiaojie0cluster\" (\"curveXiaoJie\" + \".cv[0:1]\");\ncluster -n \"xiaojie1cluster\" (\"curveXiaoJie\" + \".cv[2]\");\ncluster -n \"xiaojie2cluster\" (\"curveXiaoJie\" + \".cv[3]\");\ncluster -n \"xiaojie3cluster\" (\"curveXiaoJie\" + \".cv[4]\");\ncluster -n \"xiaojie4cluster\" (\"curveXiaoJie\" + \".cv[5]\");\ncluster -n \"xiaojie5cluster\" (\"curveXiaoJie\" + \".cv[6]\");\ncluster -n \"xiaojie6cluster\" (\"curveXiaoJie\" + \".cv[7]\");\ncluster -n \"xiaojie7cluster\" (\"curveXiaoJie\" + \".cv[8:9]\");\nselect -r \"xiaojie*clusterHandle\" ;\n//\nCreateEmptyGroup;rename \"rolltwist\";\nselect -tgl \"_handleXiaoJie\" ;\ntwistroll;\n////\nselect $skirt0 xiaojie0clusterHandle;AIPcon;\nselect $skirt1;danxuanlast; select -add xiaojie7clusterHandle;\nduochongaddcon2;\nselect $skirt0 $selectObj[0];duochongaddcon2;\n\nint $weizhiA=`size($skirt1)`/2/2/2;//1\nselect $skirt1[$weizhiA];\nint $weizhiB=`size ($skirt1)`/2/2;//2\nselect -add $skirt1[$weizhiB];\nint $weizhiC=$weizhiB/2+$weizhiB/2+$weizhiB/2;//3\nselect -add $skirt1[$weizhiC];\nint $weizhiD=`size ($skirt1)`/4+`size($skirt1)`/4+1;//4\nselect -add $skirt1[$weizhiD];\nint $weizhiE=`size ($skirt1)`/2+$weizhiB/2+$weizhiB/4;//5\nselect -add $skirt1[$weizhiE];\nint $weizhiF=`size ($skirt1)`/3+`size($skirt1)`/2;//6\nselect -add $skirt1[$weizhiF];\n//select -add $skirt1[`size ($skirt1)`-2];//7\naddlotbake;\nstring $ss[]=`ls-sl`;\nselect $ss[0] xiaojie1clusterHandle;duochongaddcon2;\nselect $ss[1] xiaojie2clusterHandle;duochongaddcon2;\nselect $ss[2] xiaojie3clusterHandle;duochongaddcon2;\nselect $ss[3] xiaojie4clusterHandle;duochongaddcon2;\nselect $ss[4] xiaojie5clusterHandle;duochongaddcon2;\nselect $ss[5] xiaojie6clusterHandle;duochongaddcon2;\n\nselect \"xiaojie*clusterHandle\";select -d xiaojie0clusterHandle;\nsonbakeT;foundconmubiao;delete;\nselect $ss;delete;\n}\n////////////////////\n////////////////////\n////////////////////\n////////////////////\n////////////////////\nselect $skirt0 \"xiaojie*clusterHandle\";\nselect -d xiaojie0clusterHandle;\nstring $conzhi[]=`ls-sl`;\nLtW_point;\n//\nselect $GGo2;\nQA_pickTarget;\nselect $skirt1;\nQA_pickOrigin;\nQAapllycon(0,1);\nselect $GGo2;\nsonbakeO;\nselect $GGo2;pickWalk -d down;delete;\nQAapllycon(1,1);\n//\nselect $conzhi;foundconsaki;pickWalk -d up;\nselect -add rolltwist;group;outlinecolor(000);\nselect $selectObj[0] _handleXiaoJie \ncurveXiaoJie \"xiaojie*clusterHandle\";\ngroup;outlinecolor(000);\nstring $mingziall[]=`ls-sl`;HideSelectedObjects;\nselect $mingziall rolltwist $selectObj[0] _handleXiaoJie curveXiaoJie \"xiaojie*clusterHandle\";\ngaimingzi(\"X_\");\nselect -cl;\n}//3-4-5  9>rig kazu  99>e ra-\n//addnewrig_autoXP(9);" 
            -optionBox 0
            -enable 1
            -visible 1
            -data 0
            -allowOptionBoxes 1
            -postMenuCommandOnce 0
            -enableCommandRepeat 1
            -echoCommand 0
            -italicized 0
            -boldFont 1
            -sourceType "mel" 
            -longDivider 1
            menuEditorMenuItem11;

        mennuu
            -label "addnewrig_GuLianMake" 
            -divider 0
            -subMenu 0
            -tearOff 0
            -command "global proc BuildBoneChain_aimConstraint(){\nstring $reversework[] = `ls-sl`;\nCreateLocator;rename \"reverseG\";\npointConstraint -n \"ssscon\" $reversework[0] \"reverseG\";\norientConstraint -n \"ssscon\" $reversework[0] \"reverseG\";\nselect \"reverseG\";\nGetFormLocator3;rename \"uplot\";\n\nint $Lotallaa =`size($reversework)`;\nint $x;\nint $y;\nfor ($x = 0;$x < $Lotallaa; $x++){\nselect reverseG; \njoint ;rename (\"reverse\"+$x+\"joint\");\nstring $newjoint[] = `ls-sl`;\nselect $reversework[$x] $newjoint[0];\nAIPcon;\nselect $newjoint[0];CurveOperation \"Rzero\";\npickWalk -d down;pickWalk -d right;delete;\n}\nselect \"reverse*joint\";\nstring $selectObj[] = `ls -sl`;\nmakeIdentity -apply true -t 0 -r 0 -s 1 -n 0;\nfor($ma=1; $ma < (size($selectObj)+1); $ma++){ \nif ($ma < size($selectObj)){ \nparent $selectObj[$ma] $selectObj[$ma-1] ;\n}}\n\nselect \"reverse*joint\";\njoint -e  -oj xyz -secondaryAxisOrient yup -ch -zso;\n//jointori\nstring $newjoint2[] = `ls -sl`;\nfor ($x = 0;$x < $Lotallaa; $x++){\nif($x<$Lotallaa-1){\n$y=$x+1;}else{$y=0;}print $y;\n\n//last joint Orient\nselect \"reverse*joint\";\nfor($lastjointfound in `ls -sl`){ \nselect $lastjointfound;\n}\nstring $J_lastding[] = `ls -sl`;\nsetAttr ($J_lastding[0]+\".jointOrientX\") 0;\nsetAttr ($J_lastding[0]+\".jointOrientY\") 0;\nsetAttr ($J_lastding[0]+\".jointOrientZ\") 0;\n//\nselect $reversework[$y] $newjoint2[$x];\naimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 \n-upVector 0 1 0 -worldUpType \"object\" -worldUpObject \"uplot\";\n}\n\nselect \"reverse*joint\";\nsonbakeO;\n\nselect -r reverseG ;\nsonbakeTO;\ndelete \"reverse*joint_aimConstraint*\" ssscon ssscon1 uplot;\n//deleteUI addsprig;\n}\n\n/////////////////////////////////////////////////////////\nglobal proc BuildBoneChain_poConstraint(){\nstring $setjointwork[] = `ls-sl`;\nCreateLocator;rename \"setjointG\";\npointConstraint -n \"ssscon\" $setjointwork[0] \"setjointG\";\nsonbakeT;\nint $Lotallaa =`size($setjointwork)`;\nint $x;\nfor ($x = 0;$x < $Lotallaa; $x++){\nselect setjointG; \njoint ;rename (\"setjoint\"+$x+\"joint\");\nstring $newjoint[] = `ls-sl`;\nselect $setjointwork[$x] $newjoint[0];\nAIPcon;\nselect $setjointwork[$x] $newjoint[0];\nAIOcon;\n}\nselect \"setjoint*joint\";\nstring $selectObj[] = `ls -sl`;\nmakeIdentity -apply true -t 0 -r 0 -s 1 -n 0;\nfor($ma=1; $ma < (size($selectObj)+1); $ma++){ \nif ($ma < size($selectObj)){ \nparent $selectObj[$ma] $selectObj[$ma-1] ;\n}}\n\nselect \"setjoint*joint\";\nsonbakeTO;\npickWalk -d down;delete;\nselect \"setjoint*joint\";\npickWalk -d down;\nselect -tgl ssscon;\ndelete;\n//deleteUI addsprig;\n}\n/////////////////////////////////////////////////////////\nglobal proc Wbonchain_aim(){\nstring $AAsele[]= `ls-sl`;\nBuildBoneChain_aimConstraint;\nselect -r reverseG ;SelectHierarchy;select -d \"*Shape\";\nstring $newname = \"AA_\";\nfor($work in `ls -sl`){\nrename $work ($newname+$work);\n}\n//////////////////\nstring $selectObjold[] = `ls -sl`;\nselect -d `ls -type \"joint\"`;\nstring $lot[] = `ls -sl`;\nselect $selectObjold;select -d $lot;\nstring $selectObj[] = `ls -sl`;\nint $ff= `size($selectObj)`-1;\nfor($x=$ff;$x > -1;$x--){\nselect -add $selectObj[$x];\n}\nBuildBoneChain_aimConstraint;\nselect -r reverseG ;SelectHierarchy;select -d \"*Shape\";\nstring $newnamee = \"BB_\";\nfor($work in `ls -sl`){\nrename $work ($newnamee+$work);\n}\nselect -cl;//deleteUI addsprig;\n}\n/////////////////////////////////////////////////////////\nglobal proc springsetA(float $beishu){//sel abcd rig\nstring $quickrigjoint[] = `ls-sl`;\nselect $quickrigjoint[0];addlot;\nrename \"quickrighoint\";\nselect $quickrigjoint;\nGetFormLocator2;\nstring $Lotallq[] = `ls-sl`;\nint $yy =`size($Lotallq)`;\nfor ($x = 0;$x < $yy; $x++){\nselect $Lotallq[$x];joint;\nrename (\"xxoo\" + $x);\n}\nselect $Lotallq;pickWalk -d down;pickWalk -d right;\nstring $Jointallq[] = `ls -sl`;\nmakeIdentity -apply true -t 0 -r 0 -s 1 -n 0;\nfor($ma=1; $ma < (size($Jointallq)+1); $ma++){ \nif ($ma < size($Jointallq)){ \nparent $Jointallq[$ma] $Jointallq[$ma-1] ;\n}\n}rename \"xxooend\";duplicate -rr;select -tgl \"xxooend\";parent;rename \"deletjoint\";\n\nparent \"xxoo0\" \"quickrighoint\";\nselect \"xxoo0\";\njoint -e  -oj xyz -secondaryAxisOrient yup -ch -zso;\ndelete $Lotallq \"deletjoint\";\nselect \"xxooend\";duplicate -rr;select -tgl \"xxooend\";parent;rename \"xxoonokey\";\nmove -r -os -wd 0.15 0 0 ;\nselect \"xxoo*\";\n//\nstring $Jointallqq[] = `ls-sl`;\nmakeIdentity -apply true -t 0 -r 0 -s 1 -n 0;\nfor($ma=0; $ma < (size($Jointallqq)+1); $ma++){\nif ($ma < size($Jointallqq)){ \nselect $Jointallqq[$ma];\nsetAttr \".radius\" 0.01;\n}\n}\ndelete xxoonokey ;\n////////////\nselect -r xxoo0 xxooend ;\nstring $selwj[]=`ls-sl`;\nikHandle -sol ikSplineSolver -ns 4 -n lishen;\ndelete lishen;\nselect $selwj[0];\nSelectHierarchy;\nint $selejshu = size( `ls -sl -type joint` );\nrename curve1 sscurve;\njointoncurve($selejshu*$beishu,\"sscurve\");\nparent piaopiaogu1 quickrighoint;\ndelete xxoo0 sscurve;\nselect quickrighoint;\nsonbakeTO;foundconmubiao;delete;\n//\nselect \"piaopiaogu1\";SelectHierarchy;\nmakeIdentity -apply true -t 0 -r 1 -s 0 -n 0 -pn 1;\nstring $newj[]=`ls-sl`;\nif($beishu==1){\n//for($i = 0; $i !=(`size($newj)`-1);$i++){\nfor($i = 0; $i !=(`size($newj)`);$i++){\nselect $newj[$i];\nGetFormLocator3;\nselect -tgl $quickrigjoint[$i];\nsunxujiaohuan;\nbeizhu(2);\n}\n}\nselect -r quickrighoint ;outlinecolor(010);\nlishigai($quickrigjoint[0]+\"_\");select -cl;\n}//springsetA(1)\n/////////////////////////////////////////////////////////\nglobal proc springsetB(){\n//sele shouRigO\nstring $handRzidongwork[]=`ls-sl`;\nCreateLocator;rename \"autoshouA\";\njoint -p 0 0 0;rename \"autoshouB\";\njoint -p 0 0 0;rename \"autoshouC\";\nparentConstraint -weight 1 $handRzidongwork[0] \"autoshouA\";\nselect \"autoshouA\";sonbakeTO;\nselect $handRzidongwork[1] \"autoshouC\";\npointConstraint -offset 0 0 0 -weight 1;\npointConstraint -remove;\nselect \"autoshouB\";\njoint -e  -oj xyz -secondaryAxisOrient zup -ch -zso;\nselect -r autoshouB;\nGetFormLocator3;\nselect -tgl $handRzidongwork[0];\nsunxujiaohuan;beizhu(2);\nselect -r autoshouA;outlinecolor(010);\nlishigai($handRzidongwork[0]+\"_\");select -cl;\n}//springsetB;\n/////////////////////////////////////////////////////////\nglobal proc springsetC(int $beishu){\n//sel abcd rig 1>tong shuliang  2>2bei\nstring $quickrigjoint[] = `ls-sl`;\nselect $quickrigjoint[0];addlot;\nrename \"quickrighoint\";\nselect $quickrigjoint;\nGetFormLocator2;\nstring $Lotallq[] = `ls-sl`;\nint $yy =`size($Lotallq)`;\nfor ($x = 0;$x < $yy; $x++){\nselect $Lotallq[$x];joint;\nrename (\"xxoo\" + $x);\n}\nselect $Lotallq;pickWalk -d down;pickWalk -d right;\nstring $Jointallq[] = `ls -sl`;\nmakeIdentity -apply true -t 0 -r 0 -s 1 -n 0;\nfor($ma=1; $ma < (size($Jointallq)+1); $ma++){ \nif ($ma < size($Jointallq)){ \nparent $Jointallq[$ma] $Jointallq[$ma-1] ;\n}\n}rename \"xxooend\";duplicate -rr;select -tgl \"xxooend\";parent;rename \"deletjoint\";\n\nparent \"xxoo0\" \"quickrighoint\";\nselect \"xxoo0\";\njoint -e  -oj xyz -secondaryAxisOrient yup -ch -zso;\ndelete $Lotallq \"deletjoint\";\n//\nselect \"xxoo*\";\ndanxuanlast;\nselect -tgl \"xxoo*\";\nzhugejianxuan;\nint $sss = (size( `ls -sl -type joint` ))*$beishu;\nparent xxooend xxoo0;\ndelete xxoo1;\nselect -r xxoo0 xxooend;\nSplitJointChain($sss);\n///////////\nselect quickrighoint;\nsonbakeTO;\npickWalk -d down;pickWalk -d right;delete;\nselect -r quickrighoint;\npickWalk -d down;pickWalk -d right;delete;\n//\nselect -r xxoo0;\nSelectHierarchy;\nstring $newj[]=`ls-sl`;\n\nfor($i = 0; $i != (`size($newj)`/$beishu);$i++){\nint $p =$i*$beishu;\nselect $newj[$p];     \nGetFormLocator3;\nselect -tgl $quickrigjoint[$i];\nsunxujiaohuan;\nbeizhu(2);\n}\nselect -r quickrighoint ;outlinecolor(011);\nlishigai($quickrigjoint[0]+\"_\");select -cl;\nselect ($quickrigjoint[0]+\"_xxoo0\") ($quickrigjoint[0]+\"_xxooend\");\n}//springsetC(1);\n/////////////////////////////////////////////////////////\nglobal proc lianconrig_p(){\n//骨錬反回rig時,回転不具合対策\n//rig(bei)+joint(zhu)\nstring $rig_lian_all[]=`ls-sl`;\nint $shuliang=`size ($rig_lian_all)`;\nint $g=$shuliang/2;select -cl;\nfor($i=0;$i<$g;$i++){\nselect -tgl $rig_lian_all[$i];\n}\nstring $rig_tp[]=`ls-sl`;select -cl;\nfor($p=$g;$p<$shuliang;$p++){\nselect -tgl $rig_lian_all[$p];\n}\nstring $lian_tp[]=`ls-sl`;\n///////\nfor($a=0;$a<$g;$a++){\nselect $rig_tp[$a] $lian_tp[$a];\n\nstring $rig_lian_tp[]=`ls-sl`;\nselect $rig_lian_tp[0];\nGetFormLocator2;rename \"TTTa\";\nGetFormLocator2;rename \"PPPa\";\nmove -r 0 0 250 TTTa;\nmove -r 0 200 0 PPPa;\n//\nselect $rig_lian_tp[0] TTTa PPPa;\naddaimlotB;\nstring $selTP[]=`ls-sl`;\nselect $rig_lian_tp[1] $selTP[0];LtL_point;\nselect $rig_lian_tp[1] $selTP[1];LtL_point;\nselect -cl;\n}\nselect $rig_lian_all;\n}//lianconrig_p;\n/////////////////////////////////////////////////////////" 
            -optionBox 0
            -enable 1
            -visible 1
            -data 0
            -allowOptionBoxes 1
            -postMenuCommandOnce 0
            -enableCommandRepeat 1
            -echoCommand 0
            -italicized 0
            -boldFont 1
            -sourceType "mel" 
            -longDivider 1
            menuEditorMenuItem1;

        mennuu
            -label "NunoW" 
            -divider 0
            -subMenu 0
            -tearOff 0
            -command "global proc Nuno(){ \nif (`window -exists nuuo`){deleteUI -window nuuo;}\nwindow -title \"Nuno\" nuuo;\nmenuBarLayout;\nmenu -label \"help\" -helpMenu true;\nmennuu -label \"usage\" -command Nunohelp;\nsetParent ..;\ncolumnLayout -adjustableColumn true;\nseparator -height 10 ;\n\ntext -label \"step1\" -align \"left\";\nbutton-label \"xuanzhebu\" -ann \"bu sele\" -command \"nClothCreateOptions\";\n//\ntext -label \"step2\" -align \"left\";\nbutton-label \"xuanzheVdian\" -ann \"vertex sele\" -command \"Step2\";\n//\ntext -label \"step3\" -align \"left\";\nbutton-label \"gusele\" -ann \"joint&rig allsele\" -command \"GetFormLocator2\";\n// \ntext -label \"step4\" -align \"left\"; \nbutton-label \"lot+bu\" -ann \"lot bu sele\" -command \"parentToSurface\"; \n// \ntext -label \"step5\" -align \"left\"; \nbutton-label \"pengzhuang\" -ann \"rou ti sele\" -command \"nClothMakeCollideOptions\"; \n//\nshowWindow nuuo;\n}//Nuno;\n/////////////////////////////////\n/////////////////////////////////\nglobal proc Nunohelp(){\nif(`window -ex Nunohelpwindow`) deleteUI Nunohelpwindow;\nwindow -title \"ヘルプ\" Nunohelpwindow;\ncolumnLayout;\n//↓usage\ntext \"///////////////////////////////////////////////////////////////////////////////////////////\";\ntext \"//http://area.autodesk.jp/column/tutorial/maya_atoz/ncloth_mudbox2/\";\ntext \"//http://help.autodesk.com/view/MAYAUL/2015/CHS/?guid=nCloth_nodes_nClothShape\";\ntext \"////\";\ntext \"////nucleus1: \";\ntext \"//@Start Frame @Gravity(zhongliang) @Space Scale(0.01) \";\ntext \"//dynamicConstraint1: \";\ntext \"//@P,O constraint \";\ntext \"////foliclexx: \";\ntext \"//@Damp @Stiffness @Star Curve Attract(0.01) \";\ntext \"////buliaode nCloth: \";\ntext \"//@bounce(tantiao)　@friction(moca) @damp(zuni) @stickness(nianxing) @collidestrength(pengzhuangqiangdu) \";\ntext \"///////////////////////////////////////////////////////////////////////////////////////////\";\nshowWindow;\nwindow -e -wh 560 460 Nunohelpwindow; \n} \n/////////////////////////////////\n/////////////////////////////////\nglobal proc Step2(){\nperformCreateDynamicConstraint 1 \"transform\";\n}\n//////////////////////////////////\nglobal proc float convertToCmFactor(){\nstring $unit = `currentUnit -q -linear`;\nif( $unit == \"mm\" ){\nreturn( 0.1 );\n} else if( $unit == \"cm\" ){\nreturn( 1.0 );\n} else if( $unit == \"m\" ){\nreturn( 100.0 );\n} else if( $unit == \"in\" ){\nreturn( 2.54 );\n} else if( $unit == \"ft\" ){\nreturn( 30.48 );\n} else if( $unit == \"yd\" ){\nreturn( 91.44 );\n} else {\nreturn( 1.0 );\n}\n}\n/////////////////////////\nglobal proc attachObjectToSurface(string $obj, string $surface, float $u, float $v ){\nstring $follicle = `createNode follicle`;\nstring $tforms[] = `listTransforms $follicle`;\nstring $follicleDag = $tforms[0];\n\nconnectAttr ($surface + \".worldMatrix[0]\") ($follicle + \".inputWorldMatrix\");\nstring $nType = `nodeType $surface`;\nif( \"nurbsSurface\" == $nType ){ \nconnectAttr ($surface + \".local\") ($follicle + \".inputSurface\");\n} else {\nconnectAttr ($surface + \".outMesh\") ($follicle + \".inputMesh\");\n}\nconnectAttr ($follicle + \".outTranslate\") ($follicleDag + \".translate\");\nconnectAttr ($follicle + \".outRotate\") ($follicleDag + \".rotate\");\nsetAttr -lock true ($follicleDag + \".translate\");\nsetAttr -lock true ($follicleDag + \".rotate\");\nsetAttr ($follicle + \".parameterU\") $u;\nsetAttr ($follicle + \".parameterV\") $v;\n//parent -addObject -shape $obj $follicleDag;\nparent $obj $follicleDag;\n}\n///////////////////////////////////////////\nglobal proc parentToSurface(){\nstring $sl[] = `ls -sl`;\nint $numSel =size($sl);\nif( $numSel < 2 ){\nwarning( \"ParentToSurface: select object(s) to parent followed by a mesh or nurbsSurface to attach to.\");\nreturn;\n}\nstring $surface = $sl[$numSel-1];\nif( nodeType($surface) == \"transform\" ){\nstring $shapes[] = `ls -dag -s -ni -v $surface`;\nif( size( $shapes ) > 0 ){\n$surface = $shapes[0];\n} \n}\nstring $nType = `nodeType $surface`;\nif( $nType != \"mesh\" && $nType != \"nurbsSurface\"){\nwarning( \"ParentToSurface: Last selected item must be a mesh or nurbsSurface.\");\nreturn;\n}\nstring $clPos = \"\";\nfloat $minU, $minV, $sizeU, $sizeV;\nfloat $convertFac = 1.0;\n\nif( $nType == \"nurbsSurface\" ){\n$clPos = `createNode closestPointOnSurface`; \nconnectAttr ($surface + \".worldSpace[0]\") ($clPos + \".inputSurface\");\n\n$minU = `getAttr ($surface+\".mnu\")`;\nfloat $maxU = `getAttr ($surface+\".mxu\")`;\n$sizeU = $maxU - $minU;\n$minV = `getAttr ($surface+\".mnv\")`;\nfloat $maxV = `getAttr ($surface+\".mxv\")`;\n$sizeV = $maxV - $minV;\n} else {\nint $pomLoaded = `pluginInfo -query -l nearestPointOnMesh`;\nif( !$pomLoaded ){\nloadPlugin nearestPointOnMesh;\n$pomLoaded = `pluginInfo -query -l nearestPointOnMesh`;\nif( !$pomLoaded ){\nwarning( \"ParentToSurface: Can't load nearestPointOnMesh plugin.\");\nreturn;\n}\n}\n// The following is to overcome a units bug in the nearestPointOnMesh plugin\n// If at some point it correctly handles units, then we need to take out the\n// following conversion factor. \n$convertFac = convertToCmFactor();\n\n$clPos = `createNode nearestPointOnMesh`;\nconnectAttr ($surface + \".worldMesh\") ($clPos + \".inMesh\");\n}\nint $i;\nfloat $closestU, $closestV;\nfor( $i = 0; $i < $numSel -1; $i++ ){\nstring $obj = $sl[$i];\nif( nodeType( $obj )!= \"transform\" ){\nwarning( \"ParentToSurface: select the transform of the node(s) to constrain\\n\");\ncontinue;\n}\nfloat $bbox[] = `xform -q -ws -bb $obj`;\nfloat $pos[3];\n$pos[0] = ($bbox[0] + $bbox[3])*0.5;\n$pos[1] = ($bbox[1] + $bbox[4])*0.5;\n$pos[2] = ($bbox[2] + $bbox[5])*0.5;\nsetAttr ($clPos + \".inPosition\") -type double3 \n($pos[0]*$convertFac) \n($pos[1]*$convertFac)\n($pos[2]*$convertFac);\n$closestU = getAttr( $clPos + \".parameterU\");\n$closestV = getAttr( $clPos + \".parameterV\");\nif( $nType == \"nurbsSurface\" ){\n$closestU = ($closestU + $minU)/$sizeU;\n$closestV = ($closestV + $minV)/$sizeV;\n}\nattachObjectToSurface( $obj, $surface, $closestU, $closestV );\n}\nif( $clPos != \"\" ){\ndelete $clPos;\n}\n}" 
            -optionBox 0
            -enable 1
            -visible 1
            -data 0
            -allowOptionBoxes 1
            -postMenuCommandOnce 0
            -enableCommandRepeat 1
            -echoCommand 0
            -italicized 0
            -boldFont 1
            -sourceType "mel" 
            -longDivider 1
            menuEditorMenuItem5;

        mennuu
            -label "bt_makeJointsDynamicUI" 
            -divider 0
            -subMenu 0
            -tearOff 0
            -command "// Single Chains:\n//https://www.youtube.com/watch?v=F5oPTUHN-5U\n// Each of the single chain types affects a curve which will in turn drives an IKSpline\n// Jiggle   : JiggleDeformer -> Curve -> IKSpline -> Joints\n// Softbody : Springs -> Particles -> SoftbodyCurve -> Curve -> IKSpline -> Joints\n// Hair     : HairSystem -> Folicle -> Curve -> IKSpline -> Joints\n//\n// Before applying bt_makeJointsDynamic for single chains, you must first select the root of the \n// joint chain that you wish to make dynamic, followed by the end joint.  After you choose \n// the animation driver type that you'd like to use, you will also have an option for the \n// detail of the curve that will drive the chain (Low = 4 cvs : Med = 5 cvs : High = 6 cvs).\n// Lastly you may set the falloff of the given effect.  This refers to the ammount that the\n// effect will decay from the end of the chain to the root.  The end of the chain will have \n// the most movement, the root will have no movement, and the amount of movement for the\n// joints in between will be determined by the falloff.  \n//\n// Note: In order to modify the falloff afterwards you will need to use the component editor \n// for softbodies and jiggle deformers.  \n//\n// Hair extras: In the case of hair falloff you can simply edit the stiffness \n// ramp widget in the hairsystem. For hair you can later add collision constraints.  \n// Simple sphere standins are recommended whenever possible for better results.  \n// Note: Hair will only be available in Maya Unlimited, version 6 or later.  \n// Multi Chains:\n// \n// The joint chains that you drive with nCloth must be siblings to one another.  It is\n// also generally recommended that they have the same number of joints per chain.  Before\n// applying bt_makeJointsDynamic for multi chains, you must first the root of each chain.\n// The order is important as it determines how the nCloth object gets built.  \n// The verts of the resulting nCloth mesh will match the joint postistions exactly.\n//\n// The falloff setting determines how much the static input mesh (eg original joint positions)\n// will influence, or limit the motion of the nCloth.\n//\n// There are 3 methods for linking the nCloth to the joints.\n//\n// 1. IK Spline - the is the least effective method but may be faster than simpleIK\n// An IK Spline will be create for each chain.  The end result will be joint rotations.\n//\n// 2. Simple IK - this is will create an IK handle for -each- joint/bone in each chain.\n// The end result will be joint rotations.\n//\n// 3. Joint Contraints - this will create a locator/constraint for each joint in each chain.\n// The end result will be joint translations, therefore squash and stretch can be \n// achieved.  Note: when baking joint rotations will not be affected.\n//\n// Once you've created the nCloth you may be prompted to select 1 or more\n// objects for the the nCloth to collide with.  Simply select the object(s)\n// and click the MakeCollide button.  To bypass this just click No Collisions.  You can\n// always add static mesh collision objects later using traditional methods.  \n////////////////////////////////////\n// Misc Procs\nglobal proc bt_checkPlaybackSpeed (){\t\n\tstring $playbackSpeed = `playbackOptions -q -ps`;\n\tif ($playbackSpeed != 0)\n\t{\n\tstring $result = `confirmDialog -title \"Playback Speed Check\" -message \"For best results your playback speed should be set to : play every frame \\n\\n\\                               Would you like to change it now?\"\n\t\t-messageAlign \"Center\" -button \"Yes\" -button \"No\" -defaultButton \"No\" -cancelButton \"No\" -dismissString \"No\"`;\n\tif ($result == \"Yes\")\n\t\tplaybackOptions -ps 0;\n\t}\t\t\n}\n///////////////////////////////////////////////////\n// Jiggle Procs\nglobal proc bt_driveJointsWithJiggle(int $detail, int $falloff){\t\t\n\tbt_checkPlaybackSpeed;\n\t\n\tstring $joints[] = `ls -sl`;\n\t\n\tstring $Normal4[] = {\"0\",\"0.333\",\"0.667\",\"1\"};\n\tstring $Normal5[] = {\"0\",\"0.25\",\"0.5\",\"0.75\",\"1\"};\n\tstring $Normal6[] = {\"0\",\"0.2\",\"0.4\",\"0.6\",\"0.8\",\"1\"};\n\n\tstring $Quick4[] = {\"0\",\"0.25\",\"0.5\",\"1\"};\n\tstring $Quick5[] = {\"0\",\"0.125\",\"0.25\",\"0.5\",\"1\"};\n\tstring $Quick6[] = {\"0\",\"0.062\",\"0.125\",\"0.25\",\"0.5\",\"1\"};\n\t\n\tstring $slow4[] = {\"0\",\"0.5\",\"0.75\",\"1\"};\n\tstring $slow5[] = {\"0\",\"0.5\",\"0.75\",\"0.875\",\"1\"};\n\tstring $slow6[] = {\"0\",\"0.5\",\"0.75\",\"0.875\",\"0.938\",\"1\"};\n\n\tstring $falloffValues[];\n\t\n\tif (`size $joints` != 2)\n\t\terror \"Jiggle Single Chain: two joints must be selected first: root joint + joint at end of chain\";\n\t\n\t//$detail : 0=4cvs 1=5cvs 2=6cvs\t\n\tstring $ikInfo[] = `ikHandle -sol ikSplineSolver -ns ($detail + 1)`; //create spline ik and curve\n\t$curveName = `rename $ikInfo[2] \"jiggleCurve#\"`;\n\tselect -r $curveName; //selects spline ik curve\n\t\n\t//Create Jiggle Node\n\t//\n\tdoJiggle 1 { \"0.5\", \"0.5\", \"1\", \"0\", \"0\", \"default\", \"\" };\n\t//$jiggleName = `deformer -type jiggle -name \"dynJoint_Jiggle#\"`;\n\t$jiggleName[0] = `rename \"jiggle1\" \"jiggleEffect#\"`;\n\t\n\t//Modify IK node for Jiggle attrs\n\t//\n\t$jiggleHandle = `rename $ikInfo[0] \"jiggleHandle#\"`;\n\tselect -r $jiggleHandle;\n\n\t//Hide normal IK attrs from channel box\n\tsetAttr ($jiggleHandle + \".displayHandle\") 1;\n\tsetAttr ($jiggleHandle + \".selectHandleY\") 2;\n\tsetAttr ($jiggleHandle + \".tx\") -k 0; setAttr ($jiggleHandle + \".ty\") -k 0; setAttr ($jiggleHandle + \".tz\") -k 0;\n\tsetAttr ($jiggleHandle + \".rx\") -k 0; setAttr ($jiggleHandle + \".ry\") -k 0; setAttr ($jiggleHandle + \".rz\") -k 0;\n\tsetAttr ($jiggleHandle + \".sx\") -k 0; setAttr ($jiggleHandle + \".sy\") -k 0; setAttr ($jiggleHandle + \".sz\") -k 0;\n\tsetAttr ($jiggleHandle + \".pvx\") -k 0; setAttr ($jiggleHandle + \".pvy\") -k 0; setAttr ($jiggleHandle + \".pvz\") -k 0;\n\tsetAttr ($jiggleHandle + \".off\") -k 0; setAttr ($jiggleHandle + \".rol\") -k 0; setAttr ($jiggleHandle + \".twi\") -k 0; setAttr ($jiggleHandle + \".ikb\") -k 0;\n\n\taddAttr -ln jiggleWeight -at double  -min 0 -max 1 -dv 1 $jiggleHandle;\n\tsetAttr -e -keyable true ($jiggleHandle + \".jiggleWeight\");\n\tconnectAttr ($jiggleHandle + \".jiggleWeight\") ($jiggleName[0] + \".jiggleWeight\");\n\t\n\taddAttr -ln jiggleStiffness -at double  -min 0 -max 1 -dv .2 $jiggleHandle;\n\tsetAttr -e -keyable true ($jiggleHandle + \".jiggleStiffness\");\n\tconnectAttr ($jiggleHandle + \".jiggleStiffness\") ($jiggleName[0] + \".stiffness\");\n\t\n\taddAttr -ln jiggleDamping -at double  -min 0 -max 1 -dv .3 $jiggleHandle;\n\tsetAttr -e -keyable true ($jiggleHandle + \".jiggleDamping\");\n\tconnectAttr ($jiggleHandle + \".jiggleDamping\") ($jiggleName[0] + \".damping\");\n\t\t\n\t\n\t////////////////////////////\t\n\t//Set falloff on jiggle verts\n\t//$detail : 0=4cvs 1=5cvs 2=6cvs\n\t//$falloff : 0=Normal 1=Quick 2=Slow\n\t$cvTotal = ($detail + 4);\t\n\t\n\t\n\tif (($cvTotal == 4) && ($falloff == 0))\n\t\t$falloffValues = $Normal4;\n\telse if (($cvTotal == 5) && ($falloff == 0))\n\t\t$falloffValues = $Normal5;\n\telse if (($cvTotal == 6) && ($falloff == 0))\n\t\t$falloffValues = $Normal6;\n\telse if (($cvTotal == 4) && ($falloff == 1))\n\t\t$falloffValues = $Quick4;\n\telse if (($cvTotal == 5) && ($falloff == 1))\n\t\t$falloffValues = $Quick5;\n\telse if (($cvTotal == 6) && ($falloff == 1))\n\t\t$falloffValues = $Quick6;\n\telse if (($cvTotal == 4) && ($falloff == 2))\n\t\t$falloffValues = $slow4;\n\telse if (($cvTotal == 5) && ($falloff == 2))\n\t\t$falloffValues = $slow5;\n\telse if (($cvTotal == 6) && ($falloff == 2))\n\t\t$falloffValues = $slow6;\n\telse \n\t\terror \"Something is wrong\";\n\t\t\t\t\n\t\n\tprint $falloffValues;\n\t\n\tint $count = 0;\n\t\t\t\t\n\twhile ($count < $cvTotal)\n\t{\t\n\t\t$cvName = ($curveName + \".cv[\" + $count + \"]\");\n\t\tfloat $val = $falloffValues[$count];\n\t\tpercent -v  $val $jiggleName[0] ($cvName) ;\n\t\t//print (\"Assigning \" + $val + \" to \" + $cvName + \"\\n\");\n\t\t$count ++;\n\t}\n\n\tselect -r $jiggleHandle;\n\n\t//print ($cvTotal + \"\\n\");\n\t//print ($falloff + \"\\n\");\n\n\twarning (\"You may need to rewind to start frame in order to see the effect of the jiggle deformer\");\n\n\t//add info to notes\n\taddAttr -sn \"nts\" -ln \"notes\" -dt \"string\" $jiggleHandle;\n\tsetAttr ($jiggleHandle+\".nts\") -type \"string\" \"The jiggleHandle contains extra attributes that indirectly control the more common attrs which exist on the jiggle deformer.  This is done so that you can easily access and edit the attrs from the channel box by selecting the jiggle handle.  You can remove these attrs or break their connection if you're more experienced with jiggle deformers and want to work with that node directly.\\r\\n\";\n\n\tprint (\"Jiggle deformer on curve attached to joint chain.  See notes on Jiggle Handle node for more details.\\n\");\n}\n/////////////////////////////\n// Softbody Procs\t\nglobal proc bt_makeSoftJointsCollide (string $partObj, string $handle){\n\tpickWalk -d down;\n\tstring $meshesAndNurbs[] = `filterExpand -sm 10 -sm 12`;\n\tselect -r $meshesAndNurbs;\n\t\n\tif (`size $meshesAndNurbs` < 1)\n\t\twarning \"No Nurbs or Meshes selected.  Nothing to collide with.\";\n\telse\n\t\t{\n\t\tcollision -r 0.5 -f 0.5  $meshesAndNurbs;\n\t\tconnectDynamic -c $meshesAndNurbs $partObj;\n\t\t}\t\t\n\n\tselect -r $handle;\n\n}\n\t\nglobal proc bt_driveJointsWithSoftbody(int $detail, int $falloff){\t\n\tbt_checkPlaybackSpeed;\n\t\n\tstring $joints[] = `ls -sl`;\n\t\t\n\tstring $Normal4[] = {\"0.3\",\"0.533\",\"0.766\",\"1\"};\n\tstring $Normal5[] = {\"0.3\",\"0.475\",\"0.65\", \"0.825\", \"1\"};\n\tstring $Normal6[] = {\"0.3\",\"0.44\",\"0.58\",\"0.72\",\"0.86\",\"1\"};\n\n\tstring $Quick4[] = {\"0.3\",\"0.4\",\"0.65\",\"1\"};\n\tstring $Quick5[] = {\"0.3\",\"0.35\",\"0.45\",\"0.65\",\"1\"};\n\tstring $Quick6[] = {\"0.3\",\"0.325\",\"0.35\",\"0.45\",\"0.65\",\"1\"};\n\t\n\tstring $slow4[] = {\"0.3\",\"0.65\",\"0.85\",\"1\"};\n\tstring $slow5[] = {\"0.3\",\"0.65\",\"0.85\",\"0.95\",\"1\"};\n\tstring $slow6[] = {\"0.3\",\"0.65\",\"0.85\",\"0.95\",\"0.975\",\"1\"};\n\t\n\tstring $falloffValues[];\n\t\n\tif (`size $joints` != 2)\n\t\terror \"Softbody Single Chain: two joints must be selected first: root joint + joint at end of chain\";\n\t\n\t\n\t//$detail : 0=4cvs 1=5cvs 2=6cvs : translates to spans\n\tstring $ikInfo[] = `ikHandle -sol ikSplineSolver -ns ($detail + 1)`; //create spline ik and curve\n\t$curveName = `rename $ikInfo[2] \"softCurve#\"`;\n\tselect -r $curveName; //selects spline ik curve\t\n\n\t//////////////////////////\n\t//Create Softbody Curve\n\t//\n\tdynCreateSoft 0 0 1 0.5 0;\n\t$softCurveName[0] = `rename \"softCurve#\"`;\n\tpickWalk -d down; pickWalk -d right; \n\t$softParticleName = `ls -sl`;\n\tpickWalk -d down;\n\t$softParticleShapeName = `ls -sl`;\n\n\t/////////////////////////\n\t//Create Gravity\n\t//\n\t$softGrav = `gravity -pos 0 0 0 -m 9.8 -att 0 -dx 0 -dy -1 -dz 0  -mxd -1  -vsh none -vex 0 -vof 0 0 0 -vsw 360 -tsr 0.5 -n \"dynJoint_SoftGravity#\"`;\n\tconnectDynamic -f $softGrav $softParticleShapeName[0];\t\n\t\n\t\n\t////////////////////////////\t\n\t//Set falloff on soft verts\n\t//$detail : 0=4cvs 1=5cvs 2=6cvs\n\t//$falloff : 0=Normal 1=Quick 2=Slow\n\t$particleTotal = ($detail + 4);\t\n\t\n\t\n\tif (($particleTotal == 4) && ($falloff == 0))\n\t\t$falloffValues = $Normal4;\n\telse if (($particleTotal == 5) && ($falloff == 0))\n\t\t$falloffValues = $Normal5;\n\telse if (($particleTotal == 6) && ($falloff == 0))\n\t\t$falloffValues = $Normal6;\n\telse if (($particleTotal == 4) && ($falloff == 1))\n\t\t$falloffValues = $Quick4;\n\telse if (($particleTotal == 5) && ($falloff == 1))\n\t\t$falloffValues = $Quick5;\n\telse if (($particleTotal == 6) && ($falloff == 1))\n\t\t$falloffValues = $Quick6;\n\telse if (($particleTotal == 4) && ($falloff == 2))\n\t\t$falloffValues = $slow4;\n\telse if (($particleTotal == 5) && ($falloff == 2))\n\t\t$falloffValues = $slow5;\n\telse if (($particleTotal == 6) && ($falloff == 2))\n\t\t$falloffValues = $slow6;\n\telse \n\t\terror \"Something is wrong\";\n\t\t\t\t\n\t\n\tprint $falloffValues;\n\t\n\tint $falloffIndexNumber = 0;\n\tint $particleCount = ($particleTotal - 1);\n\t\t\t\t\n\twhile ($falloffIndexNumber < $particleTotal)\n\t{\t\n\t\tfloat $val = $falloffValues[$falloffIndexNumber];\n\t\tparticle -e -or $particleCount -at goalPP -fv $val $softParticleShapeName[0] ;\n\t\t$particleCount --;\n\t\t$falloffIndexNumber ++;\n\t}\n\t\n\t////////////////////\n\t// Create springs\n\t//\n\t\n\tint $particleCount = 0;\n\n\t$particleID = ($softParticleShapeName[0] + \".pt[\" + $particleCount + \"]\");\n\tselect -r $particleID;\n\t$particleCount ++;\n\t$particleID = ($softParticleShapeName[0] + \".pt[\" + $particleCount + \"]\");\n\tselect -add $particleID;\n\t$softSpring = `spring  -name \"dynJoint_SoftSprings#\" -noDuplicate false -minMax true -mnd 0 -mxd 0 -useRestLengthPS true -s 1 -d 0.8 -sfw 1 -efw 1` ;\n\n\t\n\twhile ($particleCount < ($particleTotal-1))\n\t{\n\t\t$particleID = ($softParticleShapeName[0] + \".pt[\" + $particleCount + \"]\");\n\t\tselect -r $particleID;\n\t\t$particleCount ++;\n\t\t$particleID = ($softParticleShapeName[0] + \".pt[\" + $particleCount + \"]\");\n\t\tselect -add $particleID;\n\t\tselect -add $softSpring[0];\n\t\tspring -add -noDuplicate false -minMax true -mnd 0 -mxd 0 ;\n\t}\n\t\n\t///////////////////////////////\n\t//Modify IK node for soft attrs\n\t//\n\t$softHandle = `rename $ikInfo[0] \"softHandle#\"`;\n\tselect -r $softHandle;\n\n\t//Hide normal IK attrs from channel box\n\tsetAttr ($softHandle + \".displayHandle\") 1;\n\tsetAttr ($softHandle + \".selectHandleY\") 2;\n\tsetAttr ($softHandle + \".tx\") -k 0; setAttr ($softHandle + \".ty\") -k 0; setAttr ($softHandle + \".tz\") -k 0;\n\tsetAttr ($softHandle + \".rx\") -k 0; setAttr ($softHandle + \".ry\") -k 0; setAttr ($softHandle + \".rz\") -k 0;\n\tsetAttr ($softHandle + \".sx\") -k 0; setAttr ($softHandle + \".sy\") -k 0; setAttr ($softHandle + \".sz\") -k 0;\n\tsetAttr ($softHandle + \".pvx\") -k 0; setAttr ($softHandle + \".pvy\") -k 0; setAttr ($softHandle + \".pvz\") -k 0;\n\tsetAttr ($softHandle + \".off\") -k 0; setAttr ($softHandle + \".rol\") -k 0; setAttr ($softHandle + \".twi\") -k 0; setAttr ($softHandle + \".ikb\") -k 0;\n\n\tsetAttr ($softParticleShapeName[0]+\".goalWeight[0]\") 1;\n\t\n\taddAttr -ln softLooseness -at double  -min 0 -max 5 -dv 2 $softHandle;\n\tsetAttr -e -keyable true ($softHandle + \".softLooseness\");\n\tconnectAttr ($softHandle + \".softLooseness\") ($softParticleShapeName[0] + \".goalSmoothness\");\n\t\t\n\taddAttr -ln softGravity -at double  -min 0 -max 200 -dv 100 $softHandle;\n\tsetAttr -e -keyable true ($softHandle + \".softGravity\");\n\tconnectAttr ($softHandle + \".softGravity\") ($softGrav[0] + \".magnitude\");\n\t\n\taddAttr -ln softSpringStiffness -at double  -min 0 -max 100 -dv 50 $softHandle;\n\tsetAttr -e -keyable true ($softHandle + \".softSpringStiffness\");\n\tconnectAttr ($softHandle + \".softSpringStiffness\") ($softSpring[0] + \".stiffness\");\n\t\n\taddAttr -ln softSpringDamping -at double  -min 0 -max 20 -dv .2 $softHandle;\n\tsetAttr -e -keyable true ($softHandle + \".softSpringDamping\");\n\tconnectAttr ($softHandle + \".softSpringDamping\") ($softSpring[0] + \".damping\");\n\t\n\t\t\n\tgroup -n \"dynJoint_SoftStuff#\" $softHandle $softCurveName[0] $softSpring $softGrav;\n\t\n\tselect -cl;\n\t\n\t\n\tif( `window -exists collisionWin` )\n\t{\n\t\tdeleteUI collisionWin;\n\t\twindowPref -remove collisionWin;\n\t}\n\t\n\n\t//previously used for softbody collision\n\t//no longer used due to poor results\n\t//\t\n\t//window -w 244 -h 65 -menuBar true -title \"Softbody Collisions\" collisionWin;\n\t//\tcolumnLayout -adjustableColumn 1;\n\t//\trowColumnLayout  -numberOfColumns 2 -columnWidth 1 119 -columnWidth 2 119; \n\t//\t\n\t//\ttext -label \" Select collision objects: \";\n\t//\ttext -label \"  Mesh / Surface\";\n\t//\t\n\t//\tbutton -label \"Make Collide\" -c (\"bt_makeSoftJointsCollide \" + $softParticleName[0] + \" \" + $softHandle + \" ; deleteUI collisionWin ;windowPref -remove collisionWin\");\n\t//\tbutton -label \"No Collisions\" -c (\"deleteUI collisionWin ; windowPref -remove collisionWin; select -r \" + $softHandle);\n\t//\t\n\t//showWindow collisionWin;\n\t\n\tsetAttr (\"copyOf\"+$curveName+\".visibility\") 0;\n\trename (\"copyOf\"+$curveName) ($curveName+\"Goal#\");\n\n\tselect -r $softHandle;\n\t\n\twarning \"Initial softbody curve needs to be created at first frame of animation.   If you notice a problem, undo and set current frame to the beginning of the timeline.\";\n\n\t//print ($particleTotal + \"\\n\");\n\t//print ($falloff + \"\\n\");\n\n\t//add info to notes\n\taddAttr -sn \"nts\" -ln \"notes\" -dt \"string\" $softHandle;\n\tsetAttr ($softHandle+\".nts\") -type \"string\" \"The softbodyHandle contains extra attributes that indirectly control the more common attrs which exist on the various dynamics nodes.  This is done so that you can easily access and edit the attrs from the channel box by selecting the softbody handle.  You can remove these attrs or break their connection if you're more experienced with dynamics and want to work with the dynamics nodes directly.\\r\\n\";\n\n\tprint (\"Softbody curve attached to joint chain.  See notes on Softbody Handle node for more details.\\n\");\n}\t\n///////////////////////////////////////////////////\n// Hair Procs\t\nglobal proc bt_makeHairJointsCollide (string $hairSystem, string $handle){\t\n\tpickWalk -d down;\n\tstring $meshesAndNurbs[] = `filterExpand -sm 10 -sm 12`;\n\tselect -r $meshesAndNurbs;\n\t\n\tif (`size $meshesAndNurbs` < 1)\n\t\twarning \"No Nurbs or Meshes selected.  Nothing to collide with.\";\n\telse\n\t\t{\n\t\tcollision -r 1 -f 0  $meshesAndNurbs;\n\t\tconnectDynamic -c $meshesAndNurbs $hairSystem;\n\t\t}\t\t\n}\n\t\nglobal proc bt_driveJointsWithHair(int $detail, int $falloff){\t\n\tbt_checkPlaybackSpeed;\n\n\tstring $joints[] = `ls -sl`;\n\t\n\tif (`size $joints` != 2)\n\t\terror \"Hair Single Chain: two joints must be selected first: root joint + joint at end of chain\";\n\t\n\tstring $tmpIKspline[] = `ikHandle -sol ikSplineSolver -ns ($detail + 1)`; //create spline ik for curve only\n\tdelete $tmpIKspline[0] $tmpIKspline[1]; //delete handle and effector.\n\tstring $hairCurveBase = `rename $tmpIKspline[2] \"baseCurve#\"`;\n\tsetAttr ($hairCurveBase+\".visibility\") 0;\n\n\t//////////////////////////\n\t//Create Hair Curve\n\t//\t\n\tselect -r $hairCurveBase; //selects old spline ik curve\n\n\n\t//make curve dynamic creates new curve, get name:\n\t//NOTE : proc arguments changed in 8.0 ->  global proc makeCurvesDynamicHairs(int $surfaceAttach, int $snapToSurface, int $matchPosition)\n\t//makeCurvesDynamicHairs; \n\tmakeCurvesDynamicHairs 0 0 0; \n\n\n\tpickWalk -d down; //for hair system shape\n\tstring $hsys[] = `ls -sl`; //hair system name, to find follicle\n\tsetAttr ($hsys[0]+\".gravity\") 20;\n\tpickWalk -d up;\n\tstring $hsysXform[] = `ls -sl`;\n\tselect -cl;\n\n\tstring $folXform[] = `listConnections -type follicle $hsys[0]`;\n\tselect -r $folXform[0];\n\tpickWalk -d down;\n\tstring $fol[] = `ls -sl`; //odd that connection above is to transform, not shape.\n\tsetAttr ($fol[0]+ \".pointLock\") 1; //lock base end of curve.\n\tsetAttr ($folXform[0]+\".visibility\") 0;\n\t\n\tstring $tmp[] = `listConnections -s off -d on $fol[0]`; //to get output curve shape\n\tstring $hairCurve = `rename $tmp[1] \"hairCurve#\"`;\n\t\n\t//assign dynamic curve as spline ik. Could also assign as wire as a variation.\n\tstring $ikInfo[] = `ikHandle -sol ikSplineSolver -ccv false -snc true -startJoint $joints[0] -endEffector $joints[1] -pcv on -curve $hairCurve`;\n\t//parent -w $hairCurve; //unparents original curve to avoid double transform.\n\t\n\t\n\t\n\t///////////////////////////////\n\t//Modify IK node for hair attrs\n\t//\n\t$hairHandle = `rename $ikInfo[0] \"hairHandle#\"`;\n\tselect -r $hairHandle;\n\n\t//Hide normal IK attrs from channel box\n\tsetAttr ($hairHandle + \".displayHandle\") 1;\n\tsetAttr ($hairHandle + \".selectHandleY\") 2;\n\tsetAttr ($hairHandle + \".tx\") -k 0; setAttr ($hairHandle + \".ty\") -k 0; setAttr ($hairHandle + \".tz\") -k 0;\n\tsetAttr ($hairHandle + \".rx\") -k 0; setAttr ($hairHandle + \".ry\") -k 0; setAttr ($hairHandle + \".rz\") -k 0;\n\tsetAttr ($hairHandle + \".sx\") -k 0; setAttr ($hairHandle + \".sy\") -k 0; setAttr ($hairHandle + \".sz\") -k 0;\n\tsetAttr ($hairHandle + \".pvx\") -k 0; setAttr ($hairHandle + \".pvy\") -k 0; setAttr ($hairHandle + \".pvz\") -k 0;\n\tsetAttr ($hairHandle + \".off\") -k 0; setAttr ($hairHandle + \".rol\") -k 0; setAttr ($hairHandle + \".twi\") -k 0; setAttr ($hairHandle + \".ikb\") -k 0;\n\n\t//create attributes\n\taddAttr -ln hairStiffness -at double  -min -0 -max 1 -dv 0.25 $hairHandle;\n\tsetAttr -e -keyable true ($hairHandle + \".hairStiffness\");\n\tconnectAttr -f ($hairHandle + \".hairStiffness\") ($hsys[0]+\".stiffness\");\n\n\taddAttr -ln hairGravity -at double -min -10 -max 100 -dv 20 $hairHandle;\n\tsetAttr -e -keyable true ($hairHandle + \".hairGravity\");\n\tconnectAttr -f ($hairHandle + \".hairGravity\") ($hsys[0]+\".gravity\");\n\n\taddAttr -ln hairDamping -at double -min 0 -max 1 -dv 0 $hairHandle;\n\tsetAttr -e -keyable true ($hairHandle + \".hairDamping\");\n\tconnectAttr -f ($hairHandle + \".hairDamping\") ($hsys[0]+\".damp\");\n\n\taddAttr -ln hairFriction -at double -min 0 -max 1 -dv 0.1 $hairHandle;\n\tsetAttr -e -keyable true ($hairHandle + \".hairFriction\");\n\tconnectAttr -f ($hairHandle + \".hairFriction\") ($hsys[0]+\".friction\");\n\n\t//addAttr -ln hairWeight -at double -min 0 -max 100 -dv 1 $hairHandle;\n\t//setAttr -e -keyable true ($hairHandle + \".hairWeight\");\n\t//connectAttr -f ($hairHandle + \".hairWeight\") ($hsys[0]+\".dynamicsWeight\");\n\n\t\n\t////////////////////////////\t\n\t//Set falloff on stiffness\n\t//$falloff : 0=Normal 1=Quick 2=Slow\n\t\n\tif ($falloff == 0)\n\t\t\t{\n\t\t\tsetAttr ($hairHandle + \".hairStiffness\") .5;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[1].stiffnessScale_Position\") 1;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[1].stiffnessScale_FloatValue\") 0;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[0].stiffnessScale_Position\") 0;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[0].stiffnessScale_FloatValue\") 1;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[0].stiffnessScale_Interp\") 1;\n\t\t\t}\n\t\t\t\t\n\tif ($falloff == 1)\n\t\t\t{\n\t\t\tsetAttr ($hairHandle + \".hairStiffness\") .5;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[1].stiffnessScale_Position\") 1;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[1].stiffnessScale_FloatValue\") 0;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[0].stiffnessScale_Position\") 0;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[0].stiffnessScale_FloatValue\") 1;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[0].stiffnessScale_Interp\") 3;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[2].stiffnessScale_Position\") .25;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[2].stiffnessScale_FloatValue\") .25;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[2].stiffnessScale_Interp\") 3;\n\t\t\t}\n\t\t\n\tif ($falloff == 2)\n\t\t\t{\n\t\t\tsetAttr ($hairHandle + \".hairStiffness\") .5;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[1].stiffnessScale_Position\") 1;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[1].stiffnessScale_FloatValue\") 0;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[0].stiffnessScale_Position\") 0;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[0].stiffnessScale_FloatValue\") 1;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[0].stiffnessScale_Interp\") 3;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[2].stiffnessScale_Position\") .75;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[2].stiffnessScale_FloatValue\") .75;\n\t\t\tsetAttr ($hsys[0] + \".stiffnessScale[2].stiffnessScale_Interp\") 3;\n\t\t\t}\n\t\t\n\t$groupName = `group -n \"dynJoint_HairStuff#\" $hairHandle $hairCurve $hsysXform[0] ($hsysXform[0]+\"OutputCurves\")`;\t\n\t$hairHandle = (\"|\" + $groupName + \"|\" + $hairHandle);\n\n\tselect -cl;\n\n\t//previously used for collision but removed because underiable results\n\t//\n\t//if( `window -exists collisionWin` )\n\t//{\n\t//\tdeleteUI collisionWin;\n\t//\twindowPref -remove collisionWin;\n\t//}\n\t//\t\n\t//window -w 245 -h 72 -menuBar true -title \"Hair Collisions\" collisionWin;\n\t//\tcolumnLayout -adjustableColumn 1;\n\t//\trowColumnLayout  -numberOfColumns 2 -columnWidth 1 119 -columnWidth 2 119; \n\t//\t\n\t//\ttext -label \" Select collision objects: \";\n\t//\ttext -label \"  Mesh / Surface\";\n\t//\t\n\t//\tbutton -label \"Make Collide\" -c (\"bt_makeHairJointsCollide \" +  $hsys[0] + \" \" + $hairHandle + \" ; deleteUI collisionWin ;windowPref -remove collisionWin\");\n\t//\tbutton -label \"No Collisions\" -c (\"deleteUI collisionWin ; windowPref -remove collisionWin\");\n\t//\t\n\t//showWindow collisionWin;\n\t\n\trename $hairCurveBase \"baseCurve#\";\n\trename $hairCurve \"hairCurve#\";\t\n\tselect -r $hairHandle;\n\n\t//add info to notes\n\taddAttr -sn \"nts\" -ln \"notes\" -dt \"string\" $hairHandle;\n\tsetAttr ($hairHandle+\".nts\") -type \"string\" \"The hairHandle contains extra attributes that indirectly control the more common attrs that exist on the actual hairSystem node.  This is done so that you can easily access and edit the attrs from the channel box by selecting the hair handle.  You can remove these attrs or break their connection if you're more experienced with hair and want to work with the hairSystem directly.\\r\\n\";\n\n\tprint (\"Hair curve attached to joint chain.  See notes on Hair Handle node for more details.\\n\");\n\n}\n\n///////////////////////////////////////////////////\n// nCloth Procs\n\nproc bt_driveJointsWithNCloth(int $mode, int $falloff){\n\t//$mode : 1=splineIK : 2=IKexpressions : 3=JointExpressions\n\t//$topo : 1=triangles : 2=quad\n\t//$falloff : 1=mesh : 2=contraint\n\t\n\tstring $rootList[];\n\tstring $jointList[];\n\tstring $curveList[];\n\tstring $ikHandleList[];\n\tstring $locatorList[];\n\tstring $base[];\n\tstring $topo;\n\t\n\t$rootList = `ls -sl -type joint`;\n\t\t\n\tif (`size $rootList` < 2)\n\t\terror \"nCloth Multi Chain: two or more neighboring root joints must be selected first\";\n\t\n\t//select -r $rootList;\n\t//$base = `pickWalk -d up`;\n\t\n\t\n\tif (($mode < 0) || ($mode > 2))\n\t\terror \"Wrong value for Mode.  Expecting 0, 1, or 2\";\n\t\n\n\tbt_checkPlaybackSpeed;\n\n\t////////////////////////////////////\n\t//Create curves\n\t\n\tint $chainCount = 0;\n\t\n\n\n\tfor ($root in $rootList)\n\t\t{\n\t\tint $jointCount = 1;\n\t\n\t\tselect -r $root;\n\t\t$base = `pickWalk -d up`;\n\t\n\t\t$translateTemp = `xform -q -ws -t $root`;\n\t\t$curveList[$chainCount] = `curve -d 1 -p $translateTemp[0] $translateTemp[1] $translateTemp[2] -k 0 -name \"dynJoint_Curve#\"` ;\n\t\n\t\tselect -r -hi $root;\n\t\t$chain = `ls -sl -type joint`;\n\t\t$size = `size $chain`;\n\t\twhile ($jointCount <= $size-1)\n\t\t\t{\n\t\t\t//print $chain[$jointCount];\n\t\t\t$translateTemp = `xform -q -ws -t $chain[$jointCount]`;\n\t\t\tcurve -os -a -p $translateTemp[0] $translateTemp[1] $translateTemp[2] $curveList[$chainCount];\n\t\t\t$jointCount++;\n\t\t\t}\n\t\t$jointList[$chainCount] = $chain[$jointCount-1];\n\t\n\t\n\t\t////////////////////////////////////\n\t\t//Create IKSpline\n\t\tif ($mode == 0)\n\t\t\t{\n\t\t\tikHandle -sol ikSplineSolver  -createCurve 0 -sj $root -ee $jointList[$chainCount] -c $curveList[$chainCount];\n\t\t\t//take curve out of joint hierarchy\n\t\t\t//parent -w $curveList[$chainCount];\n\t\t\t}\n\t\telse //if ($mode == 1)\n\t\t//Put curve on same level as root joints\n\t\tparent $curveList[$chainCount] $base;\n\t\n\t\t$chainCount++;\n\t\t}\n\t\n\t\n\t\n\t////////////////////////////////////\n\t//create IK handles per bone and link to curve\n\t\n\tif ($mode == 1)\n\t{\n\t\tint $chainCount = 0;\n\t\t$IKgroup = `group -em -name \"dynJoint_IK_Group#\"`;\n\t\tfor ($root in $rootList)\n\t\t\t{\n\t\t\tint $jointCount = 1;\n\t\t\tselect -r -hi $root;\n\t\t\t$chain = `ls -sl -type joint`;\n\t\t\t$size = `size $chain`;\n\t\t\twhile ($jointCount <= $size-1)\n\t\t\t\t{\n\t\t\t\t$tmp  = `ikHandle -sj $chain[$jointCount-1] -ee $chain[$jointCount] -name (\"dynJoint_Chain\" + $chainCount + \"_\" + \"ikHandle\" + $jointCount + \"#\")`;\n\t\t\t\t$ikHandleList[$chainCount] = $tmp[0];\n\t\t\t\tparent  $ikHandleList[$chainCount] $IKgroup;\n\t\t\n\t\t\t\t//////////////////\n\t\t\t\t//connect ikHandles to curve points via expression\n\t\t\t\t//\n\t\t\t\t//this is hopefully a temporary solution until I figure out how to use particle emitters\n\t\t\t\t//\n\t\t\t\t$editPoint = ($curveList[$chainCount] + \".ep[\" + $jointCount + \"]\");\n\t\t\t\t$handlex = $ikHandleList[$chainCount] + \".translateX\";\n\t\t\t\t$handley = $ikHandleList[$chainCount] + \".translateY\";\n\t\t\t\t$handlez = $ikHandleList[$chainCount] + \".translateZ\";\n\t\t\t\t$expr = \"\\\"$epLocation = `xform -q -ws -t \" + $editPoint + \"`;\" + $handlex + \" = $epLocation[0]; \" + $handley + \" = $epLocation[1]; \" + $handlez + \" = $epLocation[2];\\\"\";\n\t\t\t\t \n\t\t\t\texpression -s $expr -o $ikHandleList[$chainCount] -ae 1 -uc all ;\n\t\t\t\t//////////////////\n\t\t\n\t\t\t\t$jointCount++;\n\t\t\t\t}\n\t\t\t$chainCount++;\n\t\t\t}\n\t}\n\t\n\t\n\t\n\t////////////////////////////////////\n\t//create locators per bone and link to curve\n\t\n\tif ($mode == 2)\n\t{\n\t\tint $chainCount = 0;\n\t\t$locatorGroup = `group -em -name \"dynJoint_locator_Group#\"`;\n\t\tfor ($root in $rootList)\n\t\t\t{\n\t\t\tint $jointCount = 0;\n\t\t\tselect -r -hi $root;\n\t\t\t$chain = `ls -sl -type joint`;\n\t\t\t$size = `size $chain`;\n\t\t\twhile ($jointCount <= $size-1)\n\t\t\t\t{\n\t\t\t\t$tmp  = `spaceLocator -name (\"dynJoint_Chain\" + $chainCount + \"_\" + \"jointLocator\" + $jointCount + \"#\")`;\n\t\t\t\t$locatorList[$chainCount] = $tmp[0];\n\t\t\t\tparent  $locatorList[$chainCount] $locatorGroup;\n\t\t\n\t\t\t\tpointConstraint $locatorList[$chainCount] $chain[$jointCount];\n\t\n\t\t\t\t//////////////////\n\t\t\t\t//connect ikHandles to curve points via expression\n\t\t\t\t$editPoint = ($curveList[$chainCount] + \".ep[\" + $jointCount + \"]\");\n\t\t\t\t$locatorx = $locatorList[$chainCount] + \".translateX\";\n\t\t\t\t$locatory = $locatorList[$chainCount] + \".translateY\";\n\t\t\t\t$locatorz = $locatorList[$chainCount] + \".translateZ\";\n\t\t\t\t$expr = \"\\\"$epLocation = `xform -q -ws -t \" + $editPoint + \"`;\" + $locatorx + \" = $epLocation[0]; \" + $locatory + \" = $epLocation[1]; \" + $locatorz + \" = $epLocation[2];\\\"\";\n\t\t\t\t \n\t\t\t\texpression -s $expr -o $locatorList[$chainCount] -ae 1 -uc all ;\n\t\t\t\t//////////////////\n\t\t\n\t\t\t\t$jointCount++;\n\t\t\t\t}\n\t\t\t$chainCount++;\n\t\t\t}\n\t}\n\t\n\t\n\t\n\t////////////////////////////////////\n\t//Create lofted mesh from curves\n\t\n\t$loftedMesh = `loft -ch 1 -u 1 -c 0 -ar 1 -d 1 -ss 1 -rn 0 -po 1 -rsn true -name \"dynJoint_BaseMesh#\" $curveList`;\n\t\n\t//set poly to match curve cvs\n\t$historyTemp = `listHistory`;\n\tsetAttr ($historyTemp[1]+\".polygonType\") 1;\n\tsetAttr ($historyTemp[1]+\".format\") 2;\n\tsetAttr ($historyTemp[1]+\".uType\") 3;\n\tsetAttr ($historyTemp[1]+\".vType\") 3;\n\tsetAttr ($historyTemp[1]+\".uNumber\") 1;\n\tsetAttr ($historyTemp[1]+\".vNumber\") 1;\n\t\n\tpolyNormalizeUV -normalizeType 1 -preserveAspectRatio off ;\n\t//polySubdivideFacet -dv 1 -m 0 -ch 1 $loftedMesh[0];\n\t\n\tif ($topo == 2)\n\t\tpolyTriangulate $loftedMesh[0]; //not used currently\n\tdelete -ch $loftedMesh[0];\n\t\n\tselect -r $base;\n\t$aboveBase = `pickWalk -d up`;\n\tparent $loftedMesh[0] $aboveBase;\n\t\n\t\n\t\n\t////////////////////////////////////\n\t//Create wrap deformer mesh->curves\n\t\n\tselect -r $curveList;\n\tselect -add $loftedMesh[0];\n\tCreateWrap;\n\t\n\t\n\t\n\t////////////////////////////////////\n\t//Create nCloth out of lofted mesh\n\n\tcurrentTime 0;\n\tselect -r $loftedMesh[0];\n\tcreateNCloth 0;\n\t$clothShape = `rename \"dynJoint_nCloth#\"`;\n\t\n\t\n\t\n\t\t/* Not currently used\n\t\t////////////////////////////////////\n\t\t//Create transform constraint\n\t\t//\n\t\telse if ($falloff == 2)\n\t\t{\n\t\tselect -r $loftedMesh[0];\n\t\tcreateNConstraint transform 0;\n\t\t$nConstraintShape = `ls -sl`;\n\t\tpickWalk -d up;\n\t\t$nConstraint = `ls -sl`;\n\t\n\t\t//Put constraint at same level as joints\n\t\tselect -r $base;\n\t\t$aboveBase = `pickWalk -d up`;\n\t\tparent $nConstraint[0]  $aboveBase;\n\t\n\t\t//connect falloff ramp to nComponent node\n\t\t$nCompnent = `listConnections -d 0 -s 1  ($nConstraintShape[0] + \".componentIds[0]\")`;\n\t\tconnectAttr -force ($clothRamp+\".outAlpha\") ($nCompnent[0] + \".strengthMap\");\n\t\n\t\t//set attrs\n\t\tsetAttr ($nCompnent[0] + \".componentType\") 2;\n\t\tsetAttr ($nCompnent[0] + \".strength\") 0;\n\t\tsetAttr ($nCompnent[0] + \".strength\") 1;\n\t\tsetAttr ($nConstraintShape[0] + \".strength\") 1;\n\t\t}\n\t\t*/\n\n\n\t////////////////////////////////////\n\t//Create ramp for falloff of input mesh attract\n\n\t$clothRamp = `shadingNode -asTexture ramp -name \"dynJoint_nClothFalloff#\"`;\n\t$placementNode = `shadingNode -asUtility place2dTexture`;\n\tconnectAttr ($placementNode+\".outUV\") ($clothRamp+\".uv\");\n\tconnectAttr ($placementNode+\".outUvFilterSize\") ($clothRamp+\".uvFilterSize\");\n\tsetAttr ($placementNode+\".wrapU\") 0;\n\t\n\tremoveMultiInstance -break true  ($clothRamp+\".colorEntryList[1]\");\n\tsetAttr  ($clothRamp+\".colorEntryList[0].color\") -type double3 1 1 1 ;\n\tsetAttr  ($clothRamp+\".colorEntryList[2].color\") -type double3 0 0 0 ;\n\tsetAttr  ($clothRamp+\".type\") 1;\n\n\tif ($falloff == 0)\n\t\t{\n\t\tsetAttr  ($clothRamp+\".colorEntryList[0].position\") 0.05;\n\t\tsetAttr  ($clothRamp+\".colorEntryList[2].position\") 0.30;\n\t\t}\n\n\tif ($falloff == 1)\n\t\t{\n\t\tsetAttr  ($clothRamp+\".colorEntryList[0].position\") 0.05;\n\t\tsetAttr  ($clothRamp+\".colorEntryList[2].position\") 0.10;\n\t\t}\n\n\tif ($falloff == 2)\n\t\t{\n\t\tsetAttr  ($clothRamp+\".colorEntryList[0].position\") 0.05;\n\t\tsetAttr  ($clothRamp+\".colorEntryList[2].position\") 0.75;\n\t\t}\n\n\n\t//create shader for preview of falloff\n\t//connectAttr -f ($clothRamp+\".outColor\") ($clothRamp+\"Material.color\");\n\tselect -r  $loftedMesh[0];\n\thypergraphAssignTextureToSelection  $clothRamp;\n\n\t//add note\n\t//setAttr ($clothRamp+\".notes\") -type \"string\" \"This ramp controls the falloff of the influence for the underlying input mesh attraction.  The input mesh matches the original joint positions when bt_makeJointsDynamic was applied.  The ramp allows you to adjust the dynamic affect from one end of the chain to the other.  White forces the joints (nCloth) to match their original positions.  Black allows the joints (nCloth) to move dynamically.  You can edit the ramp to see the visual represention of the falloff in the  viewport.\";\n\taddAttr -sn \"nts\" -ln \"notes\" -dt \"string\" $clothRamp;\n\tsetAttr ($clothRamp+\".nts\") -type \"string\" \"The inputMeshAttractFalloff ramp controls the falloff of the influence for the underlying input mesh attraction.  The input mesh matches the original joint positions when bt_makeJointsDynamic was applied.  The ramp allows you to adjust the dynamic affect from one end of the chain to the other.  White forces the joints (nCloth) to match their original positions.  Black allows the joints (nCloth) to move dynamically.  You can edit the ramp to see the visual represention of the falloff in the viewport.\\r\\n\";\n\n\tconnectAttr -force ($clothRamp+\".outAlpha\") ($clothShape+\".inputAttractMap\");\n\tsetAttr ($clothShape+\".inputMeshAttract\") 1;\n\tsetAttr -l true ($clothShape+\".inputMeshAttract\");  //Added lock so that presets will not over-ride setting\n\n\t\n\t//Select falloff ramp last\n\tselect -r $clothRamp;\n\tsetAttributeEditorVisible(1);\n\t\t\n\tprint \"nCloth connected to joint chains. \\n\";\n\n\n\n\t////////////////////////////////////\n\t//add collision object if needed\n\n\tif( `window -exists collisionWin` )\n\t{\n\t\tdeleteUI collisionWin;\n\t\twindowPref -remove collisionWin;\n\t}\n\t\t\n\twindow -w 245 -h 72 -menuBar true -title \"Hair Collisions\" collisionWin;\n\t\tcolumnLayout -adjustableColumn 1;\n\t\trowColumnLayout  -numberOfColumns 2 -columnWidth 1 119 -columnWidth 2 119; \n\t\t\n\t\ttext -label \" Select collision objects: \";\n\t\ttext -label \"  Mesh / Surface\";\n\t\t\n\t\tbutton -label \"Make Collide\" -c (\"makeCollideNCloth; setAttributeEditorVisible(1); warning \\\"Start frame should be set to 0 and you will need to rewind for collision to work\\\" ; deleteUI collisionWin ;windowPref -remove collisionWin\");\n\t\tbutton -label \"No Collisions\" -c (\"deleteUI collisionWin ; windowPref -remove collisionWin\");\n\tshowWindow collisionWin;\n}\n\n////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////\n\n\n\n\n\n\n\n\n\n///////////////////////////////\nglobal proc bt_makeJointsDynamic()\n{\n\t//rewind to start frame (twice)\n\tplayButtonStart; playButtonStart;\n\twarning (\"Rewinding to start frame before making joints dynamic.\");\n\n\tif (`optionVar -q dynJointDriverType` == 1)\n\t\tbt_driveJointsWithJiggle (`optionVar -q dynJointDetail` , `optionVar -q dynJointFalloff`);\n\t//else if (`optionVar -q dynJointDriverType` == 2)\n\t//\tbt_driveJointsWithSoftbody (`optionVar -q dynJointDetail` , `optionVar -q dynJointFalloff`);\n\telse if (`optionVar -q dynJointDriverType` == 0)\n\t\tbt_driveJointsWithHair (`optionVar -q dynJointDetail` , `optionVar -q dynJointFalloff`);\n\telse if (`optionVar -q dynJointDriverType` == 2)\n\t\tbt_driveJointsWithNCloth (`optionVar -q dynJointDetail` ,  `optionVar -q dynJointFalloff`);\n\telse \n\t\terror \"Something is wrong.\";\n}\n\n\t\n///////////////////////////////////////////////////\n// OptionVars\n\nglobal proc bt_setDynJointOptionVars()\n{\n\tif (`optionVar -ex dynJointDriverType` == 0)\n\t\toptionVar -intValue dynJointDriverType 0;   // 0=Hair : 1:Jiggle : X:Softbody : 2:nCloth\n\tif (`optionVar -ex dynJointDetail` == 0)\n\t\toptionVar -intValue dynJointDetail 1;  // 0=Low : 1:Med : 2:High\n\tif (`optionVar -ex dynJointFalloff` == 0)\n\t\toptionVar -intValue dynJointFalloff 0;  // 0=Normal : 1:Quick : 2:Slow\t\n}\n\nglobal proc bt_deleteDynJointOptionVars()\n{\n\toptionVar -rm dynJointDriverType;\n\toptionVar -rm dynJointDetail;\n\toptionVar -rm dynJointFalloff;\n}\n\n\t\n\n///////////////////////////////////////////////////\n// UI Proc\t\n\nglobal proc bt_makeJointsDynamicUI()\n{\n\tglobal string $dynJointDriverTypeID;\n\tglobal string $dynJointDetailNameID = \"\";\n\tglobal string $dynJointFalloffNameID = \"\";\n\tglobal string $dynJointDetailValuesID = \"\";\n\tglobal string $nClothJointMethodID = \"\";\n\t\n\tbt_setDynJointOptionVars;\n\t\n\tstring $mayaCut = `about -c`;\n\tstring $mayaType = `about -p`;\n\tint $dateCheck = `substring $mayaCut 1 4`;\n\t\n\n\t//check for Hair\t\t\n\tint $includeHair = 1;\n\tint $includeNCloth = 1;\n\n\t\n\tif( `window -exists bt_makeJointsDynamicWin` )\n\t\t{\n\t\tdeleteUI bt_makeJointsDynamicWin;\n\t\twindowPref -remove bt_makeJointsDynamicWin;\n\t\t}\n\n\n\n\twindow -w 300 -h 150 -menuBar true -title \"Make Joints Dynamic\" bt_makeJointsDynamicWin;\n\t\n\tmenu -tearOff 0 -l \"Edit\";\n\t    mennuu -l \"Reset Settings\" -ann \"Reset all setting to default values.\" -c \"bt_deleteDynJointOptionVars ; bt_makeJointsDynamicUI\";\n\n\n\tcolumnLayout -adjustableColumn 1;\n\t\n\t//////////////////////////\n\t// Driver type toggles\n\t//\n\trowColumnLayout  -numberOfColumns 4 -columnWidth 1 130 -columnWidth 2 60 -columnWidth 3 60 -columnWidth 4 85; \n\n        separator -style \"in\";separator -style \"in\";separator -style \"in\";separator -style \"in\";\n\n\t\t\n\t\tstring $tmpID = `text -label \"Single Chain    \" -align \"right\"`;\n\t\t//Temporarily assign ID to supress unnecessary error message later - no idea why, it just works :)\n\t\t$dynJointDetailNameID = $tmpID; $dynJointFalloffNameID = $tmpID; $nClothJointMethodID = $tmpID;\n\t\t\n\t\t\t\t\n\t\n\t\t$dynJointDriverTypeID = `radioCollection`;\n\t\t\t\t\n\t\tradioButton -label \"Hair\" -en $includeHair -ann \"Select 2 joints from the same chain and attach a dynamic hair curve to the chain via splineIK\"\n\t\t\t-onc \"optionVar -intValue dynJointDriverType 0 ; text -e -label \\\"Low             Medium         High\\\"  $nClothJointMethodID; text -e -label \\\"Hair Curve Detail :  \\\"  $dynJointDetailNameID; text -e -label \\\"Hair Stiffness Falloff :  \\\"  $dynJointFalloffNameID\";\n\n\t\tradioButton -label \"Jiggle\" -ann \"Select 2 joints fron the same chain and attach a jiggle deformer to the chain via splineIK\"\n\t\t\t-onc \"optionVar -intValue dynJointDriverType 1 ; text -e -label \\\"Low             Medium         High\\\"  $nClothJointMethodID; text -e -label \\\"Jiggle Curve Detail :  \\\"  $dynJointDetailNameID; text -e -label \\\"Jiggle Effect Falloff :  \\\"  $dynJointFalloffNameID\";\n\n        // Obsolete now now that there is no Maya Complete\n        //\n\t\t//radioButton -label \"Softbody\" -ann \"Attach a softbody curve to the chain via splineIK\"\n\t\t//\t-onc \"optionVar -intValue dynJointDriverType 2 ; text -e -label \\\"Low             Medium         High\\\"  $nClothJointMethodID; text -e -label \\\"Softbody Curve Detail :  \\\"  $dynJointDetailNameID; text -e -label \\\"Softbody Goal Falloff :  \\\"  $dynJointFalloffNameID\";\n\t\tseparator -style none;\t\t\t\n\n\n\t\ttext -label \"Multi Chain :  \" -align \"right\";\n\n\n\n\t\t//Cloth is not available as an option in this version of the script\n\t\tradioButton -label \"nCloth\" -en $includeNCloth -ann \"Select the base joints for 2 or more joint chains of the same size and attach an nCloth mesh\"\n\t\t\t-onc \"optionVar -intValue dynJointDriverType 2 ; text -e -label \\\"Spline IK    Per-Joint IK    Stretchy Joints\\\"  $nClothJointMethodID; text -e -label \\\"nCloth Driver Method :  \\\"  $dynJointDetailNameID; text -e -label \\\"nCloth Attract Falloff :  \\\"  $dynJointFalloffNameID\";\n\t\t\n\t\t//select correct radio button for stored type\n\t\t$buttonList = `radioCollection -q -collectionItemArray $dynJointDriverTypeID`;\n\t\tint $buttonNumber = (`optionVar -q dynJointDriverType`);\n\t\tradioCollection -e -sl $buttonList[$buttonNumber] $dynJointDriverTypeID;\n\n\t\ttext -e -label \"Single Chain :  \" $tmpID;\n\t\n\t\tsetParent ..;\n\t\t\n\t\t\n\t//////////////////////////\n\t// Detail and Falloff toggles\n\t//\n\trowColumnLayout  -numberOfColumns 4 -columnWidth 1 130 -columnWidth 2 60 -columnWidth 3 60 -columnWidth 4 85; \n\n\t\n\t\tseparator -style none;separator -style none;separator -style none;separator -style none;\n\t\tseparator -style \"in\";separator -style \"in\";separator -style \"in\";separator -style \"in\";\n\t\tseparator -style none;separator -style none;separator -style none;separator -style none;\n\n\n\t\n\t\t//Falloff\n\t\t//\t\t\n\t\tif (`optionVar -q dynJointDriverType` == 1)\n\t\t\t$dynJointFalloffNameID = `text -label \"Jiggle Effect Falloff :  \" -align \"right\"`;\n\t\t//else if (`optionVar -q dynJointDriverType` == 2)\n\t\t//\t$dynJointFalloffNameID = `text -label \"Softbody Goal Falloff :  \" -align \"right\"`;\n\t\telse if (`optionVar -q dynJointDriverType` == 0)\n\t\t\t$dynJointFalloffNameID = `text -label \"Hair Stiffness Falloff :  \" -align \"right\"`;\n\t\telse if (`optionVar -q dynJointDriverType` == 2)\n\t\t\t$dynJointFalloffNameID = `text -label \"nCloth Attract Falloff :  \" -align \"right\"`;\n\t\t\t\n\t\t\t\t\t\t\n\t\t$dynJointFalloffID = `radioCollection`;\n\t\tradioButton -label \"Normal\" -ann \"The dynamic effect will have a normal linear decay over the length of the chain\"\n\t\t\t-onc \"optionVar -intValue dynJointFalloff 0\";\n\t\t\n\t\tradioButton -label \"Quick\" \t-ann \"The dynamic effect will be more noticable over the entire chain\"\n\t\t\t-onc \"optionVar -intValue dynJointFalloff 1\";\n\t\t\n\t\tradioButton -label \"Gradual\" -ann \"The dynamic effect will be mostly at the end of the chain\"\n\t\t\t-onc \"optionVar -intValue dynJointFalloff 2\";\n\t\t\n\t\t//select correct radio button for stored type\n\t\t$buttonList = `radioCollection -q -collectionItemArray $dynJointFalloffID`;\n\t\tint $buttonNumber = (`optionVar -q dynJointFalloff`);\n\t\tradioCollection -e -sl $buttonList[$buttonNumber] $dynJointFalloffID;\n\n\n\t\t//Detail\n\t\t//\n\t\t\n\t\tif (`optionVar -q dynJointDriverType` == 1)\n\t\t\t$dynJointDetailNameID = `text -label \"Jiggle Curve Detail :  \" -align \"right\"`;\n\t\t//else if (`optionVar -q dynJointDriverType` == 2)\n\t\t//\t$dynJointDetailNameID = `text -label \"Softbody Curve Detail :  \" -align \"right\"`;\n\t\telse if (`optionVar -q dynJointDriverType` == 0)\n\t\t\t$dynJointDetailNameID = `text -label \"Hair Curve Detail :  \" -align \"right\"`;\t\t\n\t\telse if (`optionVar -q dynJointDriverType` == 2)\n\t\t\t$dynJointDetailNameID = `text -label \"nCloth Driver Method :  \" -align \"right\"`;\t\n\n\n\t\t$dynJointDetailValuesID = `radioCollection`;\n\t\tradioButton -label \"\"\n\t\t\t-onc \"optionVar -intValue dynJointDetail 0\";\n\t\t\n\t\tradioButton -label \"\" \n\t\t\t-onc \"optionVar -intValue dynJointDetail 1\";\n\t\t\n\t\tradioButton -label \"\" \n\t\t\t-onc \"optionVar -intValue dynJointDetail 2\";\n\t\t\n\t\t//select correct radio button for stored type\n\t\t$buttonList = `radioCollection -q -collectionItemArray $dynJointDetailValuesID`;\n\t\tint $buttonNumber = (`optionVar -q dynJointDetail`);\n\t\tradioCollection -e -sl $buttonList[$buttonNumber] $dynJointDetailValuesID;\n\t\t\n\n\t\tsetParent ..;\n\n\n\t\t//////////////\n\t\n\n\trowColumnLayout  -numberOfColumns 2 -columnWidth 1 130 -columnWidth 2 200;\n\t\n\t\tseparator -style none;\n\t\tif (`optionVar -q dynJointDriverType` == 2)\n\t\t\t$nClothJointMethodID = `text -align \"left\" -label \"Spline IK    Per-Joint IK    Stretchy Joints\"`;\n\t\telse\n\t\t\t$nClothJointMethodID = `text -align \"left\" -label \"Low             Medium         High\"  `;\n\n\n\tsetParent ..;\n\t\n\n\n\n\tseparator -style \"in\";\n\n\tseparator -style none;separator -style none;separator -style none;\tseparator -style none;\n\t\n\trowColumnLayout  -numberOfColumns 3 -columnWidth 1 112  -columnWidth 2 112  -columnWidth 3 112;\n\t\n\t\tseparator -style none;separator -style none;separator -style none;\n \n\t\tbutton -label \"Create\" -c \"bt_makeJointsDynamic ; deleteUI bt_makeJointsDynamicWin\";\n\t\tbutton -label \"Apply\" -c \"bt_makeJointsDynamic\";\n\t\tbutton -label \"Close\" -c \"deleteUI bt_makeJointsDynamicWin\";\n\t\n\t\n\tshowWindow;\n}//bt_makeJointsDynamicUI;" 
            -optionBox 0
            -enable 1
            -visible 1
            -data 0
            -allowOptionBoxes 1
            -postMenuCommandOnce 0
            -enableCommandRepeat 1
            -echoCommand 0
            -italicized 0
            -boldFont 1
            -sourceType "mel" 
            -longDivider 1
            menuEditorMenuItem7;

    setParent -m ..;

    mennuu
        -label "セパレータ" 
        -divider 1
        -dividerLabel "セパレータ" 
        -subMenu 0
        -tearOff 0
        -optionBox 0
        -enable 1
        -visible 1
        -data 0
        -allowOptionBoxes 1
        -postMenuCommandOnce 0
        -enableCommandRepeat 1
        -italicized 0
        -boldFont 1
        -sourceType "mel" 
        -longDivider 1
        menuEditorMenuItem15;

    mennuu
        -label "copy/paste key A<>B" 
        -divider 0
        -subMenu 0
        -tearOff 0
        -command "global proc pastkeywork_x_xyz(int $shu){//1=1f 2=mmzhen 3=2key\nglobal string $selobj[];\nglobal int $selshu;\nglobal int $sttime;\nglobal int $edtime;\nglobal int $notime;\nglobal string $mmtime;\nglobal int $channelshu;\nglobal string $selcurves[];\nglobal float $selkeyall[];son;\n\nif($selshu==1&&$shu!=3){\nGetFormLocator2;outlinecolor(110);\nrename \"beikaobeilot\";\nselect $selobj beikaobeilot;\n}else{\nselect $selobj[0];\nif($shu==1){\ntimeSliderCopyKey;\nselect $selobj;select -d $selobj[0];\ntimeSliderPasteKey false;\nselect $selobj;\n}else if($shu==2){\nselectKey -k -t $sttime ;\nif(`keyframe -an keys -q -kc`!=$channelshu){\nsetKeyframe -insert -t $sttime;\n}selectKey -clear;\ncopyKey -t $mmtime;\n//copyKey -t $mmtime -float $mmtime -option area -hierarchy none -controlPoints 0 -shape 1;\nselect $selobj;select -d $selobj[0];\npasteKey -t $mmtime -option fitReplace;\n//pasteKey -t $mmtime -float $mmtime -option fitMerge -copies 1 -connect 0 -timeOffset 0 -floatOffset 0 -valueOffset 0;\nselect $selobj;\n}else if($shu==3){\nint $a=$selkeyall[0];\n$aa=$selcurves[0];$bb=$selcurves[1];\nselectKey -k -t $a $aa;\ncopyKey;\nselectKey -k -t $a $bb;\npasteKey -time $a -float $a -option merge -copies 1 -connect 0 \n-timeOffset 0 -floatOffset 0 -valueOffset 0;\nTangentsAuto;\n}\n}\n}//pastkeywork_x_xyz(2);\n//////\n//////\n//////\n//////\n//////\n//////\nglobal proc lanrenselekeylr(int $LR){\nselectKey -clear ;\nglobal int $keyox;\nglobal float $allkeyA;\nglobal float $allkeyB;pdkey;\nif($keyox==1){\nif($LR==0){\nselectKey -k -t ($allkeyA+\":\"+`currentTime -q`);\n}else if($LR==1){\nselectKey -k -t (`currentTime -q`+\":\"+$allkeyB);\n}\n}\n}//lanrenselekeylr(1)\n//////\n//////\nglobal proc MoveKeylr(int $llrr,int $LR){\nselectKey -clear;\nglobal float $prekey;\nglobal float $nexkey;son;\nif($llrr==0 && $LR==0){\nselectKey -k -t $prekey;\nackMoveKeys \"left\";\nprint \"<o|--\";\n}else if($llrr==0 &&$LR==1){\nselectKey -k -t $prekey;\nackMoveKeys \"right\";\nprint \"o>|--\";\n}else if($llrr==1 &&$LR==0){\nselectKey -k -t $nexkey;\nackMoveKeys \"left\";\nprint \"--|<o\";\n}else if($llrr==1 &&$LR==1){\nselectKey -k -t $nexkey;\nackMoveKeys \"right\";\nprint \"--|o>\";\n}\nselectKey -clear;\n}//MoveKeylr(1,1);" 
        -optionBox 0
        -enable 1
        -visible 1
        -data 0
        -allowOptionBoxes 1
        -postMenuCommandOnce 0
        -enableCommandRepeat 1
        -echoCommand 0
        -italicized 0
        -boldFont 1
        -sourceType "mel" 
        -longDivider 1
        menuEditorMenuItem16;

    mennuu
        -label "menuEditorMenuItem17" 
        -divider 0
        -subMenu 0
        -tearOff 0
        -command "global proc ABjiaohun_keyCP(){\nglobal string $A[];\nglobal string $B[];\nglobal int $sttime;\nglobal int $edtime;\nglobal int $notime;\nglobal string $mmtime;son;\nselect $A $B;\n\nselect $A;\ncopyKey -t $mmtime;\nGetFormLocator2;\nstring $Aaa[]=`ls-sl`;\npasteKey;\nselect $B;\ncopyKey -t $mmtime;\nGetFormLocator2;\nstring $Bbb[]=`ls -sl`;\npasteKey;\n//\nselect $Bbb;\ncopyKey -t $mmtime;\nselect $A;\npasteKey -t $mmtime -option fitReplace;\nselect $Aaa;\ncopyKey -t $mmtime;\nselect $B;\npasteKey -t $mmtime -option fitReplace;\ndelete $Aaa $Bbb;\nselect $A $B;\n}//ABjiaohun_keyCP\n//////\n//////\nglobal proc AB_keyCP(){\nglobal string $A[];\nglobal string $B[];\nint $xu=0;\nfor($val in $A){\nselect $A[$xu] $B[$xu];\npastkeywork_x_xyz(2);\n$xu++;\n}select $A $B;\n}//AB_keyCP;\n\nglobal proc BA_keyCP(){\nglobal string $A[];\nglobal string $B[];\nint $xu=0;\nfor($val in $B){\nselect $B[$xu] $A[$xu];\npastkeywork_x_xyz(2);\n$xu++;\n}select $B $A;\n}//BA_keyCP;" 
        -optionBox 1
        -enable 1
        -visible 0
        -data 0
        -allowOptionBoxes 1
        -postMenuCommandOnce 0
        -enableCommandRepeat 0
        -echoCommand 0
        -italicized 0
        -boldFont 1
        -sourceType "mel" 
        -longDivider 1
        menuEditorMenuItem2;

    mennuu
        -label "f1324UI creatcurveUI" 
        -divider 0
        -subMenu 0
        -tearOff 0
        -command "global proc editorcurvepullfush(){\nif(`window -ex editorcurvepullfushW`) deleteUI editorcurvepullfushW;\nwindow -title \"f1234\" editorcurvepullfushW;\ncolumnLayout ;\nrowLayout -nc 5;\nbutton -l \"o-f1-o\" -c \"myswitch(1)\" -ann \"s+F1\";\nbutton -l \"o-f2-o\" -c \"myswitch(2)\" -ann \"s+F2\";\nbutton -l \"o-f3-o\" -c \"myswitch(3)\" -ann \"s+F3\";\nbutton -l \"o-f4-o\" -c \"myswitch(4)\" -ann \"s+F4\";\nbutton -l \"o\" -c keyjiluA keyjianjuA;\nsetParent ..;\nrowLayout -nc 5;\nbutton -l \"#<0+\" -c \"myswitch2(1)\" -ann \"F1+[oL]\";\nbutton -l \"#+<0\" -c \"myswitch2(2)\" -ann \"F1+[hG]\";\nbutton -l \"0>+#\" -c \"myswitch2(3)\" -ann \"F4+[oL]\";\nbutton -l \"+0>#\" -c \"myswitch2(4)\" -ann \"F4+[hG]\";\nbutton -l \"#\" -c keyjiluB keyjianjuB;\nsetParent ..;\nshowWindow;\n}//editorcurvepullfush;\n/////////////////////////\n/////////////////////////\nglobal proc myswitch(int $suuji){//0s\n    if(`keyframe -an keys -q -kc`==0){\n\t    global string $selcurves[];\n\t    global float $FrameA;\n        global float $FrameB;\n\t\tselectKey -k -t ($FrameA+\":\"+$FrameB) $selcurves;\n\t}\n\tglobal string $selcurves[];\n\tglobal float $FrameA;\n    global float $FrameB;son;\n\tprint (\"[-\"+$FrameA + \"-\" + $FrameB + \"-]\\n\");\n\tif($FrameA!=$FrameB)\n\t{//2s\n\t\tfor ($x=1;$x<$FrameB-$FrameA;$x++)\n\t\t{//3s\n\t\t\tif($suuji<3)\n\t\t\t{//4s\n\t\t\t\tint $aa= $FrameA+1;\n\t\t\t\tint $bb= $FrameA+$x;\n\t\t\t\tselectKey -k -t ( $aa + \":\" + $bb ) $selcurves;\n\t\t\t\tprint ( $aa + \":\" + $bb + \"|\" + \"\\n\") ;  \n\t\t\t}else\n\t\t\t{//4.1s\n\t\t\t\tint $aa = $FrameB-1;\n\t\t\t\tint $bb = $FrameB-$x;\n\t\t\t\tselectKey -k -t ( $aa + \":\" + $bb ) $selcurves;\n\t\t\t\tprint ( $aa + \":\" + $bb + \"|\" + \"\\n\") ;\n\t\t\t}//4e\n\t\t\t//////////////////\n\t\t\tswitch($suuji)\n\t\t\t{//5s\n\t\t\t\tcase 1 :\n\t\t\t\tacktooluse(11);\n\t\t\t\tbreak;\n\t\t\t\tcase 2 :\n\t\t\t\tacktooluse(12);\n\t\t\t\tbreak;\n\t\t\t\tcase 3 :\n\t\t\t\tacktooluse(13);\n\t\t\t\tbreak;\n\t\t\t\tcase 4 :\n\t\t\t\tacktooluse(14);\n\t\t\t\tbreak;\n\t\t\t}//5e\n\t\t\t//////////////////\n\t\t}//3e\n\tselectKey -clear;\n\t}else\n\t{//2.1s\n\t\tprint \"!!!!!!!!!!!!!threekey!!!!!!!!!!!!!!!!\";\n\t}//2e\n}//0e\n/////////////////////////\nglobal proc myswitch2(int $suuji2){//0s\n    if(`keyframe -an keys -q -kc`==0){\n\t    global string $selcurves[];\n\t    global float $FrameA;\n        global float $FrameB;\n\t\tselectKey -k -t ($FrameA+\":\"+$FrameB) $selcurves;\n\t}\n\tglobal string $selcurves[];\n\tglobal float $FrameA;\n    global float $FrameB;son;\n    ////\n    switch($suuji2){//2s\n\t\tcase 1 :\n\t\t\t$bbb = $FrameB+1;\n\t\t\tselectKey -k -t ( $FrameA + \":\" + $bbb ) $selcurves;\n\t\t\tprint ( $FrameA + \":\" + $bbb + \">\" + \"\\n\") ;\n\t\t\tacktooluse(7);\n\t\t\t$FrameB=$bbb;\n\t\tbreak;\n\t\tcase 2 :\n\t\t\t$aaa = $FrameA-1;\n\t\t\tselectKey -k -t ( $aaa + \":\" + $FrameB ) $selcurves;\n\t\t\tprint ( $aaa + \":\" + $FrameB + \"<\" + \"\\n\") ;\n\t\t\tacktooluse(7);\n\t\t\t$FrameA=$aaa;\n\t\tbreak;\n\t\tcase 3 :\n\t\t\tint $bbbb = $FrameB+1;\n\t\t\tselectKey -k -t ( $FrameA + \":\" + $bbbb ) $selcurves;\n\t\t\tprint ( $FrameA + \":\" + $bbbb + \">\" + \"\\n\") ;\n\t\t\tacktooluse(10);\n\t\t\t$FrameB=$bbbb;\n\t\tbreak;\n\t\tcase 4 :\n\t\t\tint $aaaa = $FrameA-1;\n\t\t\tselectKey -k -t ( $aaaa + \":\" + $FrameB ) $selcurves;\n\t\t\tprint ( $aaaa + \":\" + $FrameB + \"<\" + \"\\n\") ;\n\t\t\tacktooluse(10);\n\t\t\t$FrameA=$aaaa;\n\t\tbreak;\n\t}//2e\n\tselectKey -clear;\n}//0e\n/////////////////////////\nglobal proc keyjiluA(){\nglobal string $selcurves[];\nglobal float $FrameA;\nglobal float $FrameB;\nselectKey -k -t ($FrameA+\":\"+$FrameB) $selcurves;\nbutton -e -l ($FrameA+\"f-\"+$FrameB+\"f | \"+`size($selcurves)`+\"channel\") keyjianjuA;\n}\nglobal proc keyjiluB(){\nglobal string $selcurves[];\nglobal float $FrameA;\nglobal float $FrameB;\nselectKey -k -t ($FrameA+\":\"+$FrameB) $selcurves;  \nbutton -e -l ($FrameA+\"f-\"+$FrameB+\"f | \"+`size($selcurves)`+\"channel\") keyjianjuB;\n}" 
        -optionBox 0
        -enable 1
        -visible 1
        -data 0
        -allowOptionBoxes 1
        -postMenuCommandOnce 0
        -enableCommandRepeat 1
        -echoCommand 0
        -italicized 0
        -boldFont 1
        -sourceType "mel" 
        -longDivider 1
        menuEditorMenuItem18;

    mennuu
        -label "menuEditorMenuItem19" 
        -divider 0
        -subMenu 0
        -tearOff 0
        -command "global proc CuverEditorW(){\nif(`window -ex cuverWindow`) deleteUI cuverWindow;\nwindow -title \"sele key go\" cuverWindow;\ncolumnLayout;\nrowLayout -nc 20;\nbutton -l \".||\" -c \"acktooluse(1)\" -ann \"c+F1  acktooluse(1)\";\nbutton -l \"||.\" -c \"acktooluse(2)\" -ann \"c+F1  acktooluse(2)\";\nbutton -l \"|X|\" -c \"acktooluse(20)\" -ann \"c+a+F1  acktooluse(20)\";\nbutton -l \"|Y|\" -c \"acktooluse(21)\" -ann \"c+a+F1  acktooluse(21)\";\nbutton -l \"|<>|\"  -c \"acktooluse(28)\" -ann \"selkeyA--B LRfanzhuan acktooluse(28)\";\nbutton -l \"snapL\" -c \"acktooluse(22)\" -ann \"c+/  acktooluse(22)\";\nbutton -l \"snapR\" -c \"acktooluse(23)\" -ann \"c+\\  acktooluse(23)\";\n\nbutton -l \"L0--\" -c \"startendvalue0(0)\" -ann \"startendvalue0(0)\";\nbutton -l \"--0R\" -c \"startendvalue0(1)\" -ann \"startendvalue0(1)\";\nbutton -l \"L<==\" -c \"keytongyi(0)\" -ann \"keytongyi(0)\";\nbutton -l \"==>R\" -c \"keytongyi(1)\" -ann \"keytongyi(1)\";\n\nbutton -l \"scale suo\" -c \"scalekey(0.98)\" -ann \"-[gE]\";\nbutton -l \"scale kuo\" -c \"scalekey(1.02)\" -ann \"+[gE]\";\nbutton -l \"tangent+\" -c \"keyweitiao(-1)\" -ann \"4\";\nbutton -l \"tangent-\" -c \"keyweitiao(1)\" -ann \"5\";\n\nsetParent ..;\n\nrowLayout -nc 20;\nbutton -l \"_V_\" -c \"ackPushPull shrink\" -ann \"a+F2[]\";\nbutton -l \"_A_\" -c \"ackPushPull swell\" -ann \"a+F2[oL]\";\n\nbutton -l \"-*-| <\" -c \"MoveKeylr(0,0)\" -ann \"s+F1\";\nbutton -l \"-*-| >\" -c \"MoveKeylr(0,1)\" -ann \"s+F2\";\nbutton -l \"|-*- <\" -c \"MoveKeylr(1,0)\" -ann \"s+F3\";\nbutton -l \"|-*- >\" -c \"MoveKeylr(1,1)\" -ann \"s+F4\";\n\nbutton -l \"key <0.5\" -c \"movekeyhalf(1)\" -ann \"selkeyGO\";\nbutton -l \"key 0.5>\" -c \"movekeyhalf(2)\" -ann \"selkeyGO\";\nbutton -l \"<0.5\" -c \"$nowt=`currentTime -q`;$newtz=$nowt-0.5;currentTime $newtz\";\nbutton -l \"0.5>\" -c \"$nowt=`currentTime -q`;$newtx=$nowt+0.5;currentTime $newtx\";\n\nsetParent ..;\nshowWindow cuverWindow;\n}//CuverEditorW;\n////////\n////////\nglobal proc startendvalue0(int $LorR){//lr=01\nglobal string $selcurves[];\nglobal int $channelshu;son;\nfor ($c=0;$c<$channelshu;$c++){\n$channel = $selcurves[$c];\n$selectedIndices = `keyframe -selected -q -indexValue $channel`;\n$timeArray = `keyframe -selected -q -timeChange $channel`;\n$timevalue = `keyframe -selected -q -valueChange $channel`;\nfor ($i = 0; $i < size($timeArray); $i++){\nif($LorR==0){\n$shuzhi=$timevalue[0]*-1;\nkeyframe -relative -index $selectedIndices[$i] -valueChange $shuzhi $channel;\n}else if($LorR==1){\n$shuzhi=$timevalue[`size($timevalue)`-1]*-1;\nkeyframe -relative -index $selectedIndices[$i] -valueChange $shuzhi $channel;\n}\n}\n}\n}//startendvalue0(0)\n////////\n////////\nglobal proc keytongyi(int $LorR){//lr=01\nglobal string $selcurves[];\nglobal int $channelshu;\nglobal float $FrameA;\nglobal float $FrameB;son;\nfor($a in $selcurves){\nselectKey -k -t ($FrameA+\":\"+$FrameB) $a;\n$timevalue = `keyframe -selected -q -valueChange $a`;\nif($LorR==0){\nkeyframe -animation keys -absolute -valueChange $timevalue[0];\n}else if($LorR==1){\nkeyframe -animation keys -absolute -valueChange $timevalue[`size($timevalue)`-1];\n}\n}\nselectKey -k -t ($FrameA+\":\"+$FrameB) $selcurves;\n}//keytongyi(0)\n////////\n////////\nglobal proc scalekey(float $beilvzhi){\nglobal string $selcurves[];\nglobal int $channelshu;\nglobal string $mmkey;son;\n\nfor($c=0;$c<$channelshu;$c++){\n$channels=$selcurves[$c];\nselectKey -k -t $mmkey $channels;\n$timevalue=`keyframe -selected -q -valueChange $channels`;\nfloat $keylowest =$timevalue[0];\nfloat $keyhighest =$timevalue[0];\nfor( $time in $timevalue ){\nif($time<$keylowest){\n$keylowest=$time;\n}\nif($time>$keyhighest){\n$keyhighest=$time;\n}\n}\nfloat $middlezhi = $keylowest+($keyhighest-$keylowest)/2;\n//bufferCurve -animation \"keys\" -overwrite false;\nscaleKey -scaleSpecifiedKeys 1 -timeScale 1 -timePivot 0 -floatScale 1 \n-floatPivot 0 -valueScale $beilvzhi -valuePivot $middlezhi;\n}\nselectKey -k -t $mmkey $selcurves;\n}\n//////\n//////\nglobal proc keyweitiao(int $ol){//-1or1\nglobal string $selcurves[];son;\nfloat $rotAngAmt=1*$ol;\n\nfor ($each in $selcurves){\nfloat $selectedTimes[] = `keyframe -q -sl $each`;\nfor ($every in $selectedTimes){\n$angleBuffer = `keyTangent -t $every -q -ia $each`;\n$angleBuffer[0] = ($angleBuffer[0] + $rotAngAmt);\nfloat $angleBuffer2[] = `keyTangent -t $every -q -oa $each`;\n$angleBuffer2[0] = ($angleBuffer2[0] + $rotAngAmt);\nint $lockTan[] = `keyTangent -t $every -q -l $each`;\nkeyTangent -e -a -l false -oa $angleBuffer2[0] -ia $angleBuffer[0] -t $every $each;\nkeyTangent -t $every -e -l $lockTan[0] $each;\n}\n}\n}\n//////\n//////\nglobal proc movekeyhalf(int $lr){//1:L-0.5  2:R+0.5\nif(`keyframe -an keys -q -kc`==0){\nCurveOperation onekeyselect;\n}else{\nglobal float $timelist[];son;\nif($lr==1){\nkeyframe -animation keys -option over -absolute -timeChange ($timelist[0]-0.5);\n}else if($lr==2){\nkeyframe -animation keys -option over -absolute -timeChange ($timelist[0]+0.5);\n}\n}\n}" 
        -optionBox 1
        -enable 1
        -visible 0
        -data 0
        -allowOptionBoxes 1
        -postMenuCommandOnce 0
        -enableCommandRepeat 0
        -echoCommand 0
        -italicized 0
        -boldFont 1
        -sourceType "mel" 
        -longDivider 1
        menuEditorMenuItem3;

    mennuu
        -label "csq_f1234" 
        -divider 0
        -subMenu 0
        -tearOff 0
        -command "global proc cs_qwer_work(int $jian){\nglobal string $goo;\nif($jian==1){\n$goo=\"keysmoothGO(0.2);\";\n}else if($jian==2){\n//$goo=\"CurveOperation scalekey10;\";\n$goo=\"scaleKeyson(0.9);\";\n}else if($jian==3){\n//$goo=\"CurveOperation scalekeyP10;\";\n$goo=\"scaleKeyson(1.1);\";\n}else if($jian==4){\n$goo=\"keysmoothGO(-0.2);\";\n}else if($jian==25){\n//$goo=\"CurveOperation scalekey50;\";\n$goo=\"scaleKeyson(0.68);\";\n}else if($jian==35){\n//$goo=\"CurveOperation scalekeyP50;\";\n$goo=\"scaleKeyson(1.5);\";\n}else if($jian==100){\n//$goo=\"CurveOperation scalekey100;\";\n$goo=\"scaleKeyson(0.0);\";\n}\n//\nif(`keyframe -an keys -q -kc`==0){\nCurveOperation2 \"seleminmax\";\nCurveOperation \"setkeya_b\";\neval($goo);\nselectKey -clear;\n}//\nelse{\nglobal string $selcurves[];\nglobal int $channelshu;\nglobal int $keyjige;\nglobal float $FrameA;son;\nif($keyjige>$channelshu){\nCurveOperation \"setkeya_b\";\neval($goo);\nselectKey -k -t $FrameA $selcurves;\n}else{\nCurveOperation \"selkeya_b\";\neval($goo);\nselectKey -k -t $FrameA $selcurves;\n}\n}print $goo;\n}//cs_qwer_work(1);\n\n\n//幅を減らす（直線に近づける） → scaleKeysRelativeToEnds(0.5);\n//幅を増やす（中心を強調） → scaleKeysRelativeToEnds(1.2);\n//完全に直線にする → scaleKeysRelativeToEnds(0.0);\n//元のままにする → scaleKeysRelativeToEnds(1.0);\nglobal proc scaleKeyson(float $blendFactor) {\n    string $curves[] = `keyframe -q -name -sl`;\n    for ($curve in $curves) {\n        float $times[] = `keyframe -q -sl -timeChange $curve`;\n        float $values[] = `keyframe -q -sl -valueChange $curve`;\n\n        int $count = size($times);\n        if ($count < 3) {\n            warning (\"キーが3つ以上必要です: \" + $curve);\n            continue;\n        }\n        float $startTime = $times[0];\n        float $endTime = $times[$count - 1];\n        float $startValue = $values[0];\n        float $endValue = $values[$count - 1];\n\n        for ($i = 1; $i < $count - 1; $i++) {\n            float $t = $times[$i];\n            float $v = $values[$i];\n\n            // 線形補間で理想の値を計算（両端を結ぶ直線）\n            float $ratio = ($t - $startTime) / ($endTime - $startTime);\n            float $targetValue = $startValue + ($endValue - $startValue) * $ratio;\n\n            // blendFactor > 1.0 → 中心を強調（幅を増やす）\n            // blendFactor < 1.0 → 直線に近づける（幅を減らす）\n            float $newValue = $targetValue + ($v - $targetValue) * $blendFactor;\n\n            setKeyframe -time $t -value $newValue $curve;\n            //print(\"補正: \" + $curve + \" の \" + $t + \" → \" + $newValue + \"\\n\");\n        }\n    }currentTime `currentTime -q`;refresh -f;//現在の時間を再設定して評価を促す//強制的に画面をリフレッシュ\n    //print(\"両端を基準にして、キーの幅を調整しました。\\n\");\n}//scaleKeyson(1.1);" 
        -optionBox 0
        -enable 1
        -visible 1
        -data 0
        -allowOptionBoxes 1
        -postMenuCommandOnce 0
        -enableCommandRepeat 1
        -echoCommand 0
        -italicized 0
        -boldFont 1
        -sourceType "mel" 
        -longDivider 1
        menuEditorMenuItem23;

setParent -m ..;

